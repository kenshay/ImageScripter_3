import sys
import sip
from PyQt5.QtWidgets import QMenu
from PyQt5.QtWidgets import *
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PIL import Image as PIL_IMAGE
from imagescripter.core.image_manager import Image_Manager
from PyQt5 import Qsci
from elan import *
from PyQt5.Qsci import QsciScintilla, QsciLexerPython
import PyQt5
import os
import sys
from PyQt5 import QtWidgets, Qsci
import keyword
import pkgutil
from Script_Writer.information_getter import Information_Getter

class Editor_Class(QsciScintilla):
    ARROW_MARKER_NUM = 8
    def __init__(self, mother_widget,file_path):
        super(Editor_Class, self).__init__()
        #print('Reset Autocompetion')
        #for i in dir(self):
        #    print(i)
        # Set the default font
        #self.setMarginWidth(1, 20)

        self.mother_widget = mother_widget
        self.font = QFont()
        self.file_path = file_path
        self.font.setFamily('Courier')
        self.font.setFixedPitch(True)
        self.font.setPointSize(12)
        self.setFont(self.font)
        self.setMarginsFont(self.font)
        self.setAutoCompletionCaseSensitivity(True)
        self.setAutoCompletionReplaceWord(True)
        self.setAutoCompletionThreshold(3)

        #self.SendScintilla(QsciScintilla.SCI_FINDTEXT, 3)



        #print('################################')
        #self.setText('test')
        #print(self.findFirst('test'))

        #self.setAutoCompletionUseSingle(QsciScintilla.AcusAlways)
        ######################################################

        self.setEolMode(QsciScintilla.EolWindows)
        #self.setEolVisibility(True)
        self.setTabWidth(4)
        #self.setIndentationGuides(True)
        self.setAutoIndent(True)


        #######################################################


        # Margin 0 is used for line numbers
        fontmetrics = QFontMetrics(self.font)
        self.setMarginsFont(self.font)
        #self.setMarginWidth(1,100)
        self.setMarginWidth(0, fontmetrics.width("00000") + 6)
        self.setMarginLineNumbers(0, True)
        self.setMarginsBackgroundColor(QColor("#cccccc"))
        self.setMarginsForegroundColor(QColor("#00000"))


        #self.setMarginsBackgroundColor(QColor("#ff0000ff"))


        # Clickable margin 1 for showing markers
        self.setMarginSensitivity(1, True)
        #        self.connect(self,
        #            SIGNAL('marginClicked(int, int, Qt::KeyboardModifiers)'),
        #            self.on_margin_clicked)
        self.markerDefine(QsciScintilla.RightArrow,
                          self.ARROW_MARKER_NUM)
        self.setMarkerBackgroundColor(QColor("#ee1111"),
                                      self.ARROW_MARKER_NUM)
        # Brace matching: enable for a brace immediately before or after
        # the current position
        self.setBraceMatching(QsciScintilla.SloppyBraceMatch)
        # Current line visible with special background color
        self.setCaretLineVisible(True)
        self.setCaretLineBackgroundColor(QColor("#ffe4e4"))
        # Set Python lexer
        # Set style for Python comments (style number 1) to a fixed-width
        # courier.
        self.init_or_reset_automcompletion()
        #print('###########################')
        #for i in dir(self):
        #    print(i)




    def init_or_reset_automcompletion(self):
        try:
            print('Resetting automation')
            self.lexer = QsciLexerPython()
            self.lexer.setDefaultFont(self.font)
            ########
            self.api = Qsci.QsciAPIs(self.lexer)
            ############ ###
            #import os
            # import the desired api file
            #pyqt_path = os.path.dirname(PyQt5.__file__)
            #self.api.load(os.path.join(pyqt_path, "Qt/qsci/api/python/Python-3.6.api"))
            #import __builtin__
            #for key in keyword.kwlist + dir(__builtin__):
            #    self.api.add(key)
            #
            # for importer, name, ispkg in pkgutil.iter_modules():
            #    self.api.add(name)
            for complete in Information_Getter.get_list_of_completes():
                self.api.add(complete)
            for Application in Information_Getter.get_list_of_Applications():
                self.api.add(Application)

            ## Add autocompletion strings
            # self.api.add("aLongerString")
            # self.api.add("aDifferentString")
            # self.api.add("sOmethingElse")
            ## Compile the api for use in the lexer
            self.api.prepare()
            #######
            self.setLexer(self.lexer)
            ## Set the length of the string before the editor tries to autocomplete
            ## In practise this would be higher than 1
            ## But its set lower here to make the autocompletion more obvious
            # self.setAutoCompletionSource(QsciScintilla.AcsAPIs)
            ## ## ###
            self.setAutoCompletionCaseSensitivity(True)
            self.setAutoCompletionReplaceWord(True)
            # self.setAutoCompletionSource(PyQt5.Qsci.QsciScintilla.AcsDocument)
            self.setAutoCompletionSource(QsciScintilla.AcsAll)
            self.setAutoCompletionThreshold(3)
            text = bytearray(str.encode("Arial"))
            self.SendScintilla(QsciScintilla.SCI_STYLESETFONT, 1, text)
            # Don't want to see the horizontal scrollbar at all
            # Use raw message to Scintilla here (all messages are documented
            # here: http://www.scintilla.org/ScintillaDoc.html)
            self.SendScintilla(QsciScintilla.SCI_SETHSCROLLBAR, 0)
            # not too small
            self.setMinimumSize(600, 450)
            print('Finished')
        except Exception as e:
            print(e)
    def contextMenuEvent(self, event):
        try:
            menu = QMenu(self)
            look_up_image_Action = menu.addAction("Look Up Image")
            look_up_image_Action.triggered.connect(self.look_up_image)

            take_new_image_Action = menu.addAction("Take New Image")
            take_new_image_Action.triggered.connect(self.Take_New_Image)

            take_new_image_and_run_selection_Action = menu.addAction("Take New Image And Then Run Selection")
            take_new_image_and_run_selection_Action.triggered.connect(self.Take_New_Image_And_Run_selection)



            Overwrite_with_black_image_Action = menu.addAction("Overwrite with black image")
            Overwrite_with_black_image_Action.triggered.connect(self.Overwrite_with_black_image)


            set_offset_Action = menu.addAction("Find Offset")
            set_offset_Action.triggered.connect(self.set_offset)

            run_selection_Action = menu.addAction("Run Selection")
            run_selection_Action.triggered.connect(self.run_selected)


            quick_run_selection_Action = menu.addAction("Quick Run Selection")
            quick_run_selection_Action.triggered.connect(self.quick_run_selected)


            comment_Action = menu.addAction("Comment")
            comment_Action.triggered.connect(self.comment_out_selection)

            Un_comment_Action = menu.addAction("Un_Comment")
            Un_comment_Action.triggered.connect(self.un_comment_out_selection)

            Copy_Action = menu.addAction("Copy")
            Copy_Action.triggered.connect(self.copy)

            Undo_Action = menu.addAction("Undo")
            Undo_Action.triggered.connect(self.undo)

            paste_Action = menu.addAction("Paste")
            paste_Action.triggered.connect(self.paste)

            action = menu.exec_(self.mapToGlobal(event.pos()))
        except Exception as e:
            print(e)
    def get_highlighted_txt(self):
        try:
            #return self.wordAtLineIndex(self.getCursorPosition()[0], self.getCursorPosition()[1])
            return self.selectedText()
        except Exception as e:
            print(e)
    def look_up_image(self):
        try:
            highlighted_txt = self.get_highlighted_txt()
            List = highlighted_txt.split('.')
            App = List[0]
            Image = List[1]
            #print(highlighted_txt)
            path = Information_Getter.get_full_image_path(App,Image)
            os.system(path)
        except Exception as e:
            print(e)

    def Take_New_Image_And_Run_selection(self):
        self.Take_New_Image(wait=True)
        self.run_selected()




    def Take_New_Image(self,wait = False):
        try:
            from PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QMessageBox, QLabel
            from PyQt5.QtGui import QIcon, QPixmap
            import os
            highlighted_txt = self.get_highlighted_txt()
            List = highlighted_txt.split('.')
            App = List[0]
            image = List[1]
            path = Information_Getter.get_full_image_path(App,image)
            print(path)
            if not os.path.isfile(path):
                self.Overwrite_with_black_image()
            App_Object = eval(App)
            newimage = App_Object._get_image_of_screen_()
            Image_Manager.Update_Templet_With_Image_Path(newimage)
            image = image + '.png'
            curDur = os.getcwd()
            if wait == False:
                import subprocess
                subprocess.Popen(
                    r"C:\ImageScripter_2\python.exe C:\ImageScripter_2\Lib\site-packages\Script_Writer\Image_Converter.py " + App + ' ' + path,
                    shell=False)
            elif wait == True:
                os.system(r"C:\ImageScripter_2\python.exe C:\ImageScripter_2\Lib\site-packages\Script_Writer\Image_Converter.py " + App + ' ' + path)
            os.chdir(curDur)




        except Exception as e:
            print(e)


            #'''
            #Applications_Path = Variable_File_Getter.getVariableFromFile('Applications_Folder_Location')
            #os.chdir(str(Applications_Path))
            #os.chdir(str(App))
            #import os.path
            #if os.path.isfile(image):
            #    quit_msg = "This image already exists. Do you want to overwrite it?"
            #    MessageBox = QMessageBox()
            #    MessageBox.setIconPixmap(QPixmap(image))
            #    reply = MessageBox.question(self, 'Question',
            #                                quit_msg, QMessageBox.Yes, QMessageBox.No)
            #    if reply == MessageBox.Yes:
            #        img = PIL_IMAGE.new('RGB', (200, 200), color='black')
            #        img.save(image)
            #        path = os.path.abspath(image)
            #        print(path)
            #        os.chdir(curDur)
            #        path = os.path.abspath(image)
            #        os.chdir(curDur)
            #    else:
            #        os.system(image)
            #else:
            #    img = PIL_IMAGE.new('RGB', (200, 200), color='black')
            #    img.save(image)
            #    path = os.path.abspath(image)
            #    print(path)
            #    os.chdir(curDur)
            #    path = os.path.abspath(image)
            #    os.chdir(curDur)
            #'''










    def Overwrite_with_black_image(self):
        try:
            from PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QMessageBox, QLabel
            from PyQt5.QtGui import QIcon, QPixmap
            import os
            highlighted_txt = self.get_highlighted_txt()
            List = highlighted_txt.split('.')
            App = List[0]
            image = List[1]
            #print(highlighted_txt)
            #path = Information_Getter.get_full_image_path(App,Image)
            image = image + '.png'
            curDur = os.getcwd()
            Applications_Path = Variable_File_Getter.getVariableFromFile('Applications_Folder_Location')
            os.chdir(str(Applications_Path))
            os.chdir(str(App))

            import os.path
            if os.path.isfile(image):
                quit_msg = "This image already exists. Do you want to overwrite it?"
                MessageBox = QMessageBox()
                MessageBox.setIconPixmap(QPixmap(image))
                reply = MessageBox.question(self, 'Question',
                                            quit_msg, QMessageBox.Yes, QMessageBox.No)
                if reply == MessageBox.Yes:
                    img = PIL_IMAGE.new('RGB', (200, 200), color='black')
                    img.save(image)
                    path = os.path.abspath(image)
                    print(path)
                    os.chdir(curDur)
                    path = os.path.abspath(image)
                    os.chdir(curDur)
                else:
                    os.system(image)
            else:
                img = PIL_IMAGE.new('RGB', (200, 200), color='black')
                img.save(image)
                path = os.path.abspath(image)
                print(path)
                os.chdir(curDur)
                path = os.path.abspath(image)
                os.chdir(curDur)








        except Exception as e:
            raise
            #print(e)



















    def run_selected(self):
        try:
            highlighted_txt = self.get_highlighted_txt()
            self.mother_widget.run_line_clicked(highlighted_txt)

            #List = highlighted_txt.split('.')
            #App = List[0]
            #Image = List[1]
            #print(highlighted_txt)
            #path = Information_Getter.get_full_image_path(App,Image)
            #print(path)
            #print(App)
            #os.system(path)
        except Exception as e:
            print(e)



    def quick_run_selected(self):
        try:
            highlighted_txt = self.get_highlighted_txt()
            self.mother_widget.Quick_run_line_clicked(highlighted_txt)

            #List = highlighted_txt.split('.')
            #App = List[0]
            #Image = List[1]
            #print(highlighted_txt)
            #path = Information_Getter.get_full_image_path(App,Image)
            #print(path)
            #print(App)
            #os.system(path)
        except Exception as e:
            print(e)








    def comment_out_selection(self):
        try:
            cursor = self.cursor()
            All_Text = self.text()
            All_Text = '"""\n' + All_Text + '\n"""'
            self.setText(All_Text)
            self.setCursor(cursor)
            #self.setCaretForegroundColor(QColor("#ff0000ff"))
            self.setCaretLineVisible(True)
            #self.setCaretLineBackgroundColor(QColor("#1f0000ff"))
            self.setCaretWidth(2)



        except Exception as e:
            print(e)

    def un_comment_out_selection(self):
        try:
            cursor = self.cursor()
            All_Text = self.text()
            All_Text = All_Text.replace('"""','')
            All_Text = All_Text.replace("'''",'')
            self.setText(All_Text)
            self.setCursor(cursor)
        except Exception as e:
            print(e)




    def set_offset(self):
        try:
            import os
            highlighted_txt = self.get_highlighted_txt()
            List = highlighted_txt.split('.')
            App = List[0]
            Image = List[1]
            run_txt = App + '.' + Image + '.Wait(seconds = 2)'
            exec(run_txt)
            #self.mother_widget.run_for_offset(run_txt)
            import subprocess
            subprocess.Popen(
                r"C:\ImageScripter_2\python.exe C:\ImageScripter_2\Lib\site-packages\Script_Writer\offset_tool.py",
                shell=True)
            #os.system(r"C:\ImageScripter_2\python.exe C:\ImageScripter_2\Lib\site-packages\Script_Writer\offset_tool.py")
            #path = Information_Getter.get_full_image_path(App,Image)
            #print(path)
            #print(App)
            #os.system(path)
        except Exception as e:
            print(e)







    def on_margin_clicked(self, nmargin, nline, modifiers):
        try:
            # Toggle marker for the line the margin was clicked on
            if self.markersAtLine(nline) != 0:
                self.markerDelete(nline, self.ARROW_MARKER_NUM)
            else:
                self.markerAdd(nline, self.ARROW_MARKER_NUM)
        except Exception as e:
            print(e)


if __name__ == "__main__":
    app = QApplication(sys.argv)
    a = QsciLexerPython
    editor = Editor_Class(a)
    editor.showMaximized()
    editor.setText('')
    #editor.setText(open(sys.argv[0]).read())
    app.exec_()
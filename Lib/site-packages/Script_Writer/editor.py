import sys
import sip
from PyQt5.QtWidgets import QMenu
from PyQt5.QtWidgets import *
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5 import Qsci
from PyQt5.Qsci import QsciScintilla, QsciLexerPython
import PyQt5
import os
import sys
from PyQt5 import QtWidgets, Qsci
import keyword
import pkgutil
from Script_Writer.information_getter import Information_Getter

class Editor_Class(QsciScintilla):
    ARROW_MARKER_NUM = 8
    def __init__(self, mother_widget):
        super(Editor_Class, self).__init__()
        print('Reset Autocompetion')
        for i in dir(self):
            print(i)
        # Set the default font
        self.mother_widget = mother_widget
        self.font = QFont()
        self.font.setFamily('Courier')
        self.font.setFixedPitch(True)
        self.font.setPointSize(12)
        self.setFont(self.font)
        self.setMarginsFont(self.font)
        self.setAutoCompletionCaseSensitivity(True)
        self.setAutoCompletionReplaceWord(True)
        #self.setAutoCompletionUseSingle(QsciScintilla.AcusAlways)
        ######################################################

        self.setEolMode(QsciScintilla.EolWindows)
        #self.setEolVisibility(True)
        self.setTabWidth(4)
        #self.setIndentationGuides(True)
        self.setAutoIndent(True)


        #######################################################


        # Margin 0 is used for line numbers
        fontmetrics = QFontMetrics(self.font)
        self.setMarginsFont(self.font)
        self.setMarginWidth(0, fontmetrics.width("00000") + 6)
        self.setMarginLineNumbers(0, True)
        self.setMarginsBackgroundColor(QColor("#cccccc"))
        self.setMarginsForegroundColor(QColor("#00000"))


        #self.setMarginsBackgroundColor(QColor("#ff0000ff"))


        # Clickable margin 1 for showing markers
        self.setMarginSensitivity(1, True)
        #        self.connect(self,
        #            SIGNAL('marginClicked(int, int, Qt::KeyboardModifiers)'),
        #            self.on_margin_clicked)
        self.markerDefine(QsciScintilla.RightArrow,
                          self.ARROW_MARKER_NUM)
        self.setMarkerBackgroundColor(QColor("#ee1111"),
                                      self.ARROW_MARKER_NUM)
        # Brace matching: enable for a brace immediately before or after
        # the current position
        self.setBraceMatching(QsciScintilla.SloppyBraceMatch)
        # Current line visible with special background color
        self.setCaretLineVisible(True)
        self.setCaretLineBackgroundColor(QColor("#ffe4e4"))
        # Set Python lexer
        # Set style for Python comments (style number 1) to a fixed-width
        # courier.
        self.init_or_reset_automcompletion()
        print('###########################')
        for i in dir(self):
            print(i)




    def init_or_reset_automcompletion(self):
        try:
            print('Resetting automation')
            self.lexer = QsciLexerPython()
            self.lexer.setDefaultFont(self.font)
            ########
            self.api = Qsci.QsciAPIs(self.lexer)
            ############ ###
            #import os
            # import the desired api file
            #pyqt_path = os.path.dirname(PyQt5.__file__)
            #self.api.load(os.path.join(pyqt_path, "Qt/qsci/api/python/Python-3.6.api"))
            #import __builtin__
            #for key in keyword.kwlist + dir(__builtin__):
            #    self.api.add(key)
            #
            # for importer, name, ispkg in pkgutil.iter_modules():
            #    self.api.add(name)
            for complete in Information_Getter.get_list_of_completes():
                self.api.add(complete)
            for Application in Information_Getter.get_list_of_Applications():
                self.api.add(Application)

            ## Add autocompletion strings
            # self.api.add("aLongerString")
            # self.api.add("aDifferentString")
            # self.api.add("sOmethingElse")
            ## Compile the api for use in the lexer
            self.api.prepare()
            #######
            self.setLexer(self.lexer)
            ## Set the length of the string before the editor tries to autocomplete
            ## In practise this would be higher than 1
            ## But its set lower here to make the autocompletion more obvious
            self.setAutoCompletionThreshold(1)
            # self.setAutoCompletionSource(QsciScintilla.AcsAPIs)
            ## ## ###
            self.setAutoCompletionCaseSensitivity(False)
            self.setAutoCompletionReplaceWord(False)
            # self.setAutoCompletionSource(PyQt5.Qsci.QsciScintilla.AcsDocument)
            self.setAutoCompletionSource(QsciScintilla.AcsAll)
            self.setAutoCompletionThreshold(1)
            text = bytearray(str.encode("Arial"))
            self.SendScintilla(QsciScintilla.SCI_STYLESETFONT, 1, text)
            # Don't want to see the horizontal scrollbar at all
            # Use raw message to Scintilla here (all messages are documented
            # here: http://www.scintilla.org/ScintillaDoc.html)
            self.SendScintilla(QsciScintilla.SCI_SETHSCROLLBAR, 0)
            # not too small
            self.setMinimumSize(600, 450)
            print('Finished')
        except Exception as e:
            print(e)
    def contextMenuEvent(self, event):
        try:
            menu = QMenu(self)
            look_up_image_Action = menu.addAction("Look Up Image")
            look_up_image_Action.triggered.connect(self.look_up_image)

            set_offset_Action = menu.addAction("Set Offset")
            set_offset_Action.triggered.connect(self.set_offset)

            run_selection_Action = menu.addAction("Run Selection")
            run_selection_Action.triggered.connect(self.run_selected)

            comment_Action = menu.addAction("Comment")
            comment_Action.triggered.connect(self.comment_out_selection)

            Un_comment_Action = menu.addAction("Un_Comment")
            Un_comment_Action.triggered.connect(self.un_comment_out_selection)

            Copy_Action = menu.addAction("Copy")
            Copy_Action.triggered.connect(self.copy)

            Undo_Action = menu.addAction("Undo")
            Undo_Action.triggered.connect(self.undo)

            paste_Action = menu.addAction("Paste")
            paste_Action.triggered.connect(self.paste)

            action = menu.exec_(self.mapToGlobal(event.pos()))
        except Exception as e:
            print(e)
    def get_highlighted_txt(self):
        try:
            #return self.wordAtLineIndex(self.getCursorPosition()[0], self.getCursorPosition()[1])
            return self.selectedText()
        except Exception as e:
            print(e)
    def look_up_image(self):
        try:
            highlighted_txt = self.get_highlighted_txt()
            List = highlighted_txt.split('.')
            App = List[0]
            Image = List[1]
            #print(highlighted_txt)
            path = Information_Getter.get_full_image_path(App,Image)
            os.system(path)
        except Exception as e:
            print(e)


    def run_selected(self):
        try:
            highlighted_txt = self.get_highlighted_txt()
            self.mother_widget.run_line_clicked(highlighted_txt)

            #List = highlighted_txt.split('.')
            #App = List[0]
            #Image = List[1]
            #print(highlighted_txt)
            #path = Information_Getter.get_full_image_path(App,Image)
            #print(path)
            #print(App)
            #os.system(path)
        except Exception as e:
            print(e)




    def comment_out_selection(self):
        try:
            cursor = self.cursor()
            All_Text = self.text()
            All_Text = '"""\n' + All_Text + '\n"""'
            self.setText(All_Text)
            self.setCursor(cursor)
            #self.setCaretForegroundColor(QColor("#ff0000ff"))
            self.setCaretLineVisible(True)
            #self.setCaretLineBackgroundColor(QColor("#1f0000ff"))
            self.setCaretWidth(2)

            

        except Exception as e:
            print(e)

    def un_comment_out_selection(self):
        try:
            cursor = self.cursor()
            All_Text = self.text()
            All_Text = All_Text.replace('"""','')
            All_Text = All_Text.replace("'''",'')
            self.setText(All_Text)
            self.setCursor(cursor)
        except Exception as e:
            print(e)




    def set_offset(self):
        try:
            highlighted_txt = self.get_highlighted_txt()
            List = highlighted_txt.split('.')
            App = List[0]
            Image = List[1]
            #print(highlighted_txt)
            path = Information_Getter.get_full_image_path(App,Image)
            print(path)
            print(App)
            #os.system(path)
        except Exception as e:
            print(e)







    def on_margin_clicked(self, nmargin, nline, modifiers):
        try:
            # Toggle marker for the line the margin was clicked on
            if self.markersAtLine(nline) != 0:
                self.markerDelete(nline, self.ARROW_MARKER_NUM)
            else:
                self.markerAdd(nline, self.ARROW_MARKER_NUM)
        except Exception as e:
            print(e)


if __name__ == "__main__":
    app = QApplication(sys.argv)
    a = QsciLexerPython
    editor = Editor_Class(a)
    editor.showMaximized()
    editor.setText('')
    #editor.setText(open(sys.argv[0]).read())
    app.exec_()
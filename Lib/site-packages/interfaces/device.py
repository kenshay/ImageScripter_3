from paths import *

import cv2
from PIL import Image
import time
from imagescripter.core.widget_control import *
from imagescripter.core.variable_file_getter import Variable_File_Getter
import os
from shutil import copyfile
import cv2
import numpy as np
import scipy
import webcolors
try:
    from scipy.stats import itemfreq
except:
    pass

def closest_colour(requested_colour):
    min_colours = {}
    for key, name in webcolors.css3_hex_to_names.items():
        r_c, g_c, b_c = webcolors.hex_to_rgb(key)
        rd = (r_c - requested_colour[0]) ** 2
        gd = (g_c - requested_colour[1]) ** 2
        bd = (b_c - requested_colour[2]) ** 2
        min_colours[(rd + gd + bd)] = name
    return min_colours[min(min_colours.keys())]


def Get_Dom_Color_Technical(image):
    img = image
    average_color = [img[:, :, i].mean() for i in range(img.shape[-1])]
    arr = np.float32(img)
    pixels = arr.reshape((-1, 3))
    n_colors = 5
    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 200, .1)
    flags = cv2.KMEANS_RANDOM_CENTERS
    _, labels, centroids = cv2.kmeans(pixels, n_colors, None, criteria, 10, flags)
    palette = np.uint8(centroids)
    quantized = palette[labels.flatten()]
    quantized = quantized.reshape(img.shape)
    # And finally the dominant colour is the palette colour which occurs most frequently on the quantized image:
    dominant_color = palette[np.argmax(scipy.stats.itemfreq(labels)[:, -1])]
    #print(dominant_color)
    return dominant_color

def get_colour_name(requested_colour):
    try:
        closest_name = actual_name = webcolors.rgb_to_name(requested_colour)
    except ValueError:
        closest_name = closest_colour(requested_colour)
        actual_name = None
    return actual_name, closest_name




def log_Current_Thresh_Match(variable):
    try:
        ##Variable_File_Getter.setFileFromVariable('Current_Thresh_Match.txt',variable)
        with open(Current_Thresh_Match,'w') as f:
            f.write(variable)


    except Exception as e:
        print(e)
def log_Current_Image_Cordinates(x1,y1,x2,y2):
    variable = str(x1) + ',' + str(y1) + ',' + str(x2) + ',' + str(y2)
    try:
        #Variable_File_Getter.setFileFromVariable('Current_Image_Cordinates.txt',variable)
        with open(Current_Image_Cordinates,'w') as f:
            f.write(variable)
    except Exception as e:
        print(e)

def log_Current_x_y(x,y):
    variable = str(x) + ',' + str(y)
    try:
        #Variable_File_Getter.setFileFromVariable('last_x_y.txt',variable)
        with open(last_x_y,'w') as f:
            f.write(variable)
    except Exception as e:
        print(e)








class Device_Class():
    classtype = "Default"
    def __init__(self,list_of_tags = None,ip_address = None, port = None,user_name = None, password = None):
        ##########################################
        self.PushButton = PushButton_Class(self)
        self.Edit = Edit_Class(self)
        self.EditBox = Edit_Class(self)
        self.ListView = ListView_Class(self)
        self.ListBox = ListBox_Class(self)
        self.ComboBox = ComboBox_Class(self)
        self.RadioButton = RadioButton_Class(self)
        self.CheckBox = CheckBox_Class(self)
        ###############################################
        ##self.Last_Target_Image_Path = Variable_File_Getter.getVariableFromFile("Last_Target_Image_Location")
        self.Last_Target_Image_Path = Target_Path








        #self.Last_Templet_Image_Path = Variable_File_Getter.getVariableFromFile("Last_Templet_Image_Location")
        self.Last_Templet_Image_Path = Template_Path

        self._class_name_ = None
        self._self_tags_ = list_of_tags
        self._ipadress_ = ip_address
        try:
            self._port_ = int(port)
        except:
            self._port_ = port
        self._username_ = user_name
        self._password_ = password
        self._class_name_ = self.__class__.__name__

    def Get_IP(self):
        if self._ipadress_ != 'None':
            return self._ipadress_
        else:
            return None

    def GetText(self,roi=None):
        if roi == None:
            print('Getting text on screen')
            actual_img_path = self._get_image_of_screen_()
            print(actual_img_path)
            # self._get_image_of_screen_()
            text = self._get_text_from_image_(actual_img_path)
            print(text)
            print('############Shortened####################')
            print(''.join(e for e in text if e.isalnum()))
            return text
        else:
            print('Getting text on screen')
            actual_img_path = self._get_image_of_screen_()
            print(actual_img_path)
            im = cv2.imread(actual_img_path)
            imCrop = im[int(roi[1]):int(roi[1] + roi[3]), int(roi[0]):int(roi[0] + roi[2])]
            cv2.imwrite(actual_img_path,imCrop)
            text = self._get_text_from_image_(actual_img_path)
            print(text)
            print('############Shortened####################')
            print(''.join(e for e in text if e.isalnum()))
            return text



    def GetColor(self,roi):
            print('Getting Color')
            actual_img_path = self._get_image_of_screen_()
            im = cv2.imread(actual_img_path)
            imCrop = im[int(roi[1]):int(roi[1] + roi[3]), int(roi[0]):int(roi[0] + roi[2])]
            cv2.imwrite(actual_img_path,imCrop)
            rgb = cv2.imread(actual_img_path)
            dominant_color = Get_Dom_Color_Technical(rgb)
            dominant_color = str(dominant_color)
            dominant_color = dominant_color.replace(']', '')
            dominant_color = dominant_color.replace('[', '')
            dominant_color = dominant_color.replace('   ', ' ')
            alist = dominant_color.split(' ')
            alist = [x for x in alist if x]
            r = int(alist[2])
            g = int(alist[1])
            b = int(alist[0])
            requested_colour = (r, g, b)
            actual_name, closest_name = get_colour_name(requested_colour)
            print(closest_name)
            return closest_name

    def CheckColor(self,last_color,roi,tries = 10):
        try:
            for amount_of_tries in range(tries):
                try:
                    print('Getting Color')
                    actual_img_path = self._get_image_of_screen_()
                    im = cv2.imread(actual_img_path)
                    imCrop = im[int(roi[1]):int(roi[1] + roi[3]), int(roi[0]):int(roi[0] + roi[2])]
                    cv2.imwrite(actual_img_path, imCrop)
                    rgb = cv2.imread(actual_img_path)
                    dominant_color = Get_Dom_Color_Technical(rgb)
                    dominant_color = str(dominant_color)
                    dominant_color = dominant_color.replace(']', '')
                    dominant_color = dominant_color.replace('[', '')
                    dominant_color = dominant_color.replace('   ', ' ')
                    alist = dominant_color.split(' ')
                    alist = [x for x in alist if x]
                    r = int(alist[2])
                    g = int(alist[1])
                    b = int(alist[0])
                    requested_colour = (r, g, b)
                    actual_name, closest_name = get_colour_name(requested_colour)
                    if closest_name == last_color:
                        message = f"color -> {closest_name} equals color -> {last_color}"
                        print(message)
                        return True
                    else:
                        message = f"color -> {closest_name} does not equal color -> {last_color}"
                        raise Exception(message)
                except:
                    if amount_of_tries == 9:
                        raise
                    else:
                        print(f"Trying again. {amount_of_tries} - {tries}")
                        time.sleep(1)
        except Exception as e:
            print(e)
            raise








    def CheckText(self,text,roi=None):
        text = ''.join(e for e in text if e.isalnum())
        if roi == None:
            print('Checking text on screen')
            new_text = self.GetText()
            new_text = ''.join(e for e in text if e.isalnum())
            if text == new_text:
                print("############## Found Match ###################")
            else:
                print(text)
                print(new_text)
                error = "Text Doesnt Match! {} -> {}".format(new_text,text)
                raise Exception(error)
        else:
            print('Checking text on screen')
            new_text = self.GetText(roi)
            new_text = ''.join(e for e in text if e.isalnum())
            if text == new_text:
                print("############## Found Match ###################")
            else:
                print(text)
                print(new_text)
                error = "Text Doesnt Match! {} -> {}".format(new_text,text)
                raise Exception(error)



    def GetRegion(self):
        return self.GetROI()

    def GetROI(self):
        actual_img_path = self._get_image_of_screen_()
        import cv2
        import numpy as np
        im = cv2.imread(actual_img_path)
        showCrosshair = False
        fromCenter = False
        r = cv2.selectROI("Image", im, fromCenter, showCrosshair)
        print(r)
        return r









    def __getstate__(self):
        return vars(self)

    def __setstate__(self, state):
        vars(self).update(state)

    def __getattr__(self, attr: str):
        raise AttributeError(attr + ' is not an object')




        """Return None for all unknown attributes"""
        if attr.startswith('__') and attr.endswith('__'):
            raise AttributeError
        return None

    def _get_image_of_screen_(self,attempts = 100):
        pass

    def Wait(self):
        pass

    def _get_text_from_image_(self,image_path):
        import cv2
        import pytesseract
        import numpy as np
        img = cv2.imread(r"C:\Eluminate\System\ImageScripter\TEMP\PC_Screenshot.png")
        import string
        # gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
        # gray, img_bin = cv2.threshold(gray, 128, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)
        # gray = cv2.bitwise_not(img_bin)
        # kernel = np.ones((2, 1), np.uint8)
        # img = cv2.erode(gray, kernel, iterations=1)
        # img = cv2.dilate(img, kernel, iterations=1)
        img = cv2.resize(img, None, fx=2, fy=2, interpolation=cv2.INTER_CUBIC)
        pytesseract.pytesseract.tesseract_cmd = r"C:\Eluminate\System\ImageScripter\Tesseract\tesseract.exe"
        out_below = str(pytesseract.image_to_string(img))
        out_below = "(START)\n" + out_below + '\n(END)'
        return out_below








    def _get_location_of_image_in_image(self,target_img_path,actual_img_path,threshold):
            ##past_pic_compare_location = Variable_File_Getter.getVariableFromFile('Image_Compare_Location')
            past_pic_compare_location = Image_Compare_Location
            file_name = past_pic_compare_location + '\\' + str(time.time()) + '.png'
            copyfile(target_img_path, file_name)
            file_name = past_pic_compare_location + '\\' + str(time.time()) + '.png'
            try:
                copyfile(actual_img_path, file_name)
            except FileNotFoundError:
                copyfile(loading_eyepng, file_name)
            #############################################################################################
            img = cv2.imread(target_img_path, 0)
            target_w, target_h = img.shape[::-1]
            #print('#############')
            #print(target_img_path)
            #print(self.Last_Target_Image_Path)
            try:
                copyfile(target_img_path, self.Last_Target_Image_Path)
            except OSError:
                sleep(4)
                copyfile(target_img_path, self.Last_Target_Image_Path)
            #print('#############')
            img2 = img.copy()
            template = cv2.imread(actual_img_path, 0)
            try:
                copyfile(actual_img_path, self.Last_Templet_Image_Path)
            except PermissionError:
                sleep(4)
                copyfile(actual_img_path, self.Last_Templet_Image_Path)
            w, h = template.shape[::-1]
            img = img2.copy()
            # Apply template Matching
            try:
                res = cv2.matchTemplate(img, template, cv2.TM_CCOEFF_NORMED)
            except cv2.error as e:
                print(e)
                raise ValueError('Cant find Application Window')
            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)
            Last_Max_Val = max_val
            log_Current_Thresh_Match(str(Last_Max_Val))
            if max_val >= threshold:
                #print('MaxVal -> ',max_val)
                #print('Threshold Setting -> ',threshold)
                top_left = max_loc
                bottom_right = (top_left[0] + w, top_left[1] + h)
                x, y = top_left
                ########FOR LOG
                x1 = x
                y1 = y
                x2 = x + target_w
                y2 = y + target_h
                x3 = x + (target_w / 2)
                y3 = y + (target_h / 2)



                log_Current_Image_Cordinates(x1,y1,x2,y2)
                log_Current_x_y(x3, y3)
                print('MaxVal -> ',max_val)
                print('Threshold Setting -> ',threshold)
                return x,y
            else:
                print('MaxVal -> ',max_val)
                print('Threshold Setting -> ',threshold)
                return False
    def setIPAdress(self,ip):
        self._ipadress_ = ip
    def setPort(self,port):
        self._port_ = port
    def setUserName(self,username):
        self._username_ = username
    def setPassword(self,password):
        self._password_ = password
    def _click_(self,x=0,y=0):
        pass

    def ClickXY(self, x, y):
        print('ClickXY -> ',x,y)
        self._click_(x, y)


    def _get_an_image_Width_and_height_(self,path_of_image):
        im = Image.open(path_of_image)
        return im.size






if __name__ == "__main__":
    pass

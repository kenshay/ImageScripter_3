import win32gui
import pickle
import time
import scp
import pyautogui
import shutil
import numpy as np
import cv2
import scipy
try:
    from scipy.stats import itemfreq
except:
    pass
import webcolors
import os
import sys
import os
from imagescripter.core.variable_file_getter import Variable_File_Getter
from imagescripter.core.database_manager import Database_Manager_Class
database_location = Variable_File_Getter.getVariableFromFile('Database_Location')  # name of the sqlite database file
Database_Manager = Database_Manager_Class(database_location)
import os



def Get_Dom_Color_Technical(image):
    img = image
    average_color = [img[:, :, i].mean() for i in range(img.shape[-1])]
    arr = np.float32(img)
    pixels = arr.reshape((-1, 3))
    n_colors = 5
    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 200, .1)
    flags = cv2.KMEANS_RANDOM_CENTERS
    _, labels, centroids = cv2.kmeans(pixels, n_colors, None, criteria, 10, flags)
    palette = np.uint8(centroids)
    quantized = palette[labels.flatten()]
    quantized = quantized.reshape(img.shape)
    # And finally the dominant colour is the palette colour which occurs most frequently on the quantized image:
    dominant_color = palette[np.argmax(scipy.stats.itemfreq(labels)[:, -1])]
    #print(dominant_color)
    return dominant_color



def closest_colour(requested_colour):
    min_colours = {}
    for key, name in webcolors.css3_hex_to_names.items():
        r_c, g_c, b_c = webcolors.hex_to_rgb(key)
        rd = (r_c - requested_colour[0]) ** 2
        gd = (g_c - requested_colour[1]) ** 2
        bd = (b_c - requested_colour[2]) ** 2
        min_colours[(rd + gd + bd)] = name
    return min_colours[min(min_colours.keys())]



def get_colour_name(requested_colour):
    try:
        closest_name = actual_name = webcolors.rgb_to_name(requested_colour)
    except ValueError:
        closest_name = closest_colour(requested_colour)
        actual_name = None
    return actual_name, closest_name





class Image_Class():
    def __init__(self,path_of_image,appication_object,threshold):
        self._path_of_image_ = path_of_image
        #self._application_object_ = eval(appication_object)
        pickle_off = open(appication_object, "rb")
        self._application_object_ = pickle.load(pickle_off)
        self._threshold_ = threshold
    def Exists(self,threshold = .96):
        try:
            self._application_object_.Wait()
            result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
            if result:
                print('Exists -> ',self._path_of_image_)
                return True
            else:
                print('Doesnt Exists -> ', self._path_of_image_)
                return False
        except TypeError:
            print('Doesnt Exists -> ', self._path_of_image_)
            return False

    def WaitContinue(self,seconds = 100,threshold = .96):
        self._application_object_.Wait()
        print("This is just using 'Wait', needs to be worked on to enter into database")
        try:
            self.Wait(seconds,threshold)
        except:
            print("FAILLL WAITCONTINUE")
            #raise ValueError('Need To Work On Wait Continue, Not ready')
            #Database_Manager.enter_test_results_into_database()

    def GetDominantColorClosest(self, seconds=100, threshold=.96, wait=True):
        if wait == True:
            self._application_object_.Wait()

        result = False
        for sec in range(seconds):
            try:
                image_of_screen_or_false = self._application_object_._get_image_of_screen_()
            except scp.SCPException:
                time.sleep(2)
                image_of_screen_or_false = self._application_object_._get_image_of_screen_()

            if image_of_screen_or_false != False:
                image_of_screen = image_of_screen_or_false
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,                                                                     image_of_screen, threshold)
                if result != False:
                    #########################################
                    rgb = cv2.imread(self._path_of_image_)
                    dominant_color = Get_Dom_Color_Technical(rgb)
                    # [175   0   0]
                    dominant_color = str(dominant_color)
                    print(dominant_color)
                    dominant_color = dominant_color.replace(']', '')
                    dominant_color = dominant_color.replace('[', '')
                    dominant_color = dominant_color.replace('   ', ' ')
                    alist = dominant_color.split(' ')
                    alist = [x for x in alist if x]
                    print(alist)
                    r = int(alist[2])
                    g = int(alist[1])
                    b = int(alist[0])
                    requested_colour = (r, g, b)
                    actual_name, closest_name = get_colour_name(requested_colour)
                    return str(closest_name)

        if result == False:
            raise ValueError("Image not Found->", self._path_of_image_)














    def Wait(self,seconds = 100,threshold = .96,wait = True):
        if wait == True:
            self._application_object_.Wait()

        result = False
        for sec in range(seconds):
            try:
                image_of_screen_or_false = self._application_object_._get_image_of_screen_()
            except scp.SCPException:
                time.sleep(2)
                image_of_screen_or_false = self._application_object_._get_image_of_screen_()

            if image_of_screen_or_false != False:
                image_of_screen = image_of_screen_or_false
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,image_of_screen, threshold)
                if result != False:
                    break
            print('Wating For ',self._path_of_image_,'Sec->',sec,'Total->',seconds)
            time.sleep(1)
        if result == False:
            raise ValueError("Image not Found->", self._path_of_image_)
        '''

           
            if image_of_screen_or_false != False:
                image_of_screen = image_of_screen_or_false
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,image_of_screen,threshold)
                break
            else:
                time.sleep(1)
        #if not result:
        #        print("Failed Looking For -> ", self._path_of_image_)
        #        raise ValueError("Image not Found->",self._path_of_image_)
        '''







    def WaitVanish(self,seconds = 100,threshold = .96):
        self._application_object_.Wait()
        print("Waiting For Vanish")
        try:
            for i in range(seconds):
                print(seconds)
                seconds -= 1
                try:
                    result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                except shutil.SpecialFileError as e:
                    result = None
                if not result:
                    print("Image Vanished")
                    break
                time.sleep(1)
            if result:
                    raise ValueError("Image did not disappear")
        except TypeError as e:
            print(e)
            print("Image Vanished")
    def Click(self,amount = 15,xoffset = 0,yoffset=0,threshold = .96,wait = True):
        if wait == True:
            self._application_object_.Wait()
        else:
            pass
        print('Clicking -> ', self._path_of_image_)
        for i in range(amount):
            print('Amount -> ',i,' / ',amount)
            if self._application_object_._class_name_ != "PC_Class":
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    x,y = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    #print('width',SmallWith / 2)
                    #print('height',SmallHeight / 2)
                    x = int(x + SmallWith / 2)
                    y = int(y + SmallHeight / 2)
                    break
                else:
                    print(self._path_of_image_)
            else:
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    SmallButtonX, SmallButtonY = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    handle = self._application_object_._get_most_likely_application_window_hande_by_tags_()
                    rect = win32gui.GetWindowRect(handle)
                    LargeAppX = rect[0]
                    LargeAppY = rect[1]
                    x = LargeAppX + SmallButtonX + SmallWith / 2
                    y = LargeAppY + SmallButtonY + SmallHeight / 2
                    break
                else:
                    print(self._path_of_image_)
        if result:
            x = x + xoffset
            y = y + yoffset
            print(x,y)
            self._application_object_._click_(x, y)
        else:
            #print(self._path_of_image_)
            raise ValueError("Cant find image -> " + self._path_of_image_)

    def Hover(self,amount = 15,xoffset = 0,yoffset=0,threshold = .96):
        self._application_object_.Wait()
        print('Clicking -> ', self._path_of_image_)
        for i in range(amount):
            print('Amount -> ',i,' / ',amount)
            if self._application_object_._class_name_ != "PC_Class":
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    x,y = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    #print('width',SmallWith / 2)
                    #print('height',SmallHeight / 2)
                    x = int(x + SmallWith / 2)
                    y = int(y + SmallHeight / 2)
                    break
            else:
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    SmallButtonX, SmallButtonY = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    handle = self._application_object_._get_most_likely_application_window_hande_by_tags_()
                    rect = win32gui.GetWindowRect(handle)
                    LargeAppX = rect[0]
                    LargeAppY = rect[1]
                    x = LargeAppX + SmallButtonX + SmallWith / 2
                    y = LargeAppY + SmallButtonY + SmallHeight / 2
                    break
        if result:
            x = x + xoffset
            y = y + yoffset
            print(x, y)
            self._application_object_._hover_(x, y)
        else:
            #print(self._path_of_image_)
            raise ValueError("Cant find image -> " + self._path_of_image_)



    def Hover(self,amount = 15,xoffset = 0,yoffset=0,threshold = .96):
        self._application_object_.Wait()
        print('Hover -> ', self._path_of_image_)
        for i in range(amount):
            print('Amount -> ',i,' / ',amount)
            if self._application_object_._class_name_ != "PC_Class":
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    x,y = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    #print('width',SmallWith / 2)
                    #print('height',SmallHeight / 2)
                    x = int(x + SmallWith / 2)
                    y = int(y + SmallHeight / 2)
                    break
            else:
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    SmallButtonX, SmallButtonY = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    handle = self._application_object_._get_most_likely_application_window_hande_by_tags_()
                    rect = win32gui.GetWindowRect(handle)
                    LargeAppX = rect[0]
                    LargeAppY = rect[1]
                    x = LargeAppX + SmallButtonX + SmallWith / 2
                    y = LargeAppY + SmallButtonY + SmallHeight / 2
                    break
        if result:
            x = x + xoffset
            y = y + yoffset
            print(x,y)
            self._application_object_._hover_(x, y)
        else:
            #print(self._path_of_image_)
            raise ValueError("Cant find image -> " + self._path_of_image_)





















    def ClickXY(self,x,y):
        self._application_object_._click_(x, y)



    def Max(self,amount = 15,xoffset = 0,yoffset=0,threshold = .96):
        self._application_object_.Wait()
        print('Max -> ', self._path_of_image_)
        result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
        if result:
            x,y = result
            SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
            #print('width',SmallWith / 2)
            #print('height',SmallHeight / 2)
            x = int(x + SmallWith / 2)
            y = int(y + SmallHeight / 2)
        if result:
            x = x + xoffset
            y = y + yoffset
            self._application_object_._click_(x, y)
        else:
            raise ValueError("Cant find image -> " + self._path_of_image_)








    def MaxOld(self, seconds=5, threshold='default'):
        dir_path = os.path.dirname(os.path.realpath(__file__))
        alist = dir_path.split('Elan_Tools')
        MaxImageLocation = "C:\ImageScripter_2\Lib\site-packages\elan\Applications_And_Devices\Configurator\max.png"
        handle = self.Application.GetHandle()
        templateLargeGrey = ImageGraber(handle)
        imgLarge = cv2.imread(self.ImageOfButton, 0)
        result = cv2.matchTemplate(imgLarge, templateLargeGrey, cv2.TM_CCOEFF_NORMED)
        min_val, max_val, min_loc, topLeft = cv2.minMaxLoc(result)
        # ImShow(imgLarge)
        # ImShow(templateLargeGrey)
        if max_val >= .94:
            imgHeight, imgWidth = imgLarge.shape
            x, y = topLeft
            oldX, oldY = topLeft
            x = x - 50
            topLeft = x, y
            bottomRight = (x + imgWidth, y + imgHeight)
            template = templateLargeGrey[topLeft[1]:bottomRight[1], topLeft[0]:bottomRight[0]]
            tempHeight, tempWidth = template.shape
            imgLarge = cv2.imread(MaxImageLocation, 0)
            imgHeight, imgWidth = imgLarge.shape
            result = cv2.matchTemplate(imgLarge, template, cv2.TM_CCOEFF_NORMED)
            min_val, max_val, min_loc, topLeft = cv2.minMaxLoc(result)

            SmallButtonX, SmallButtonY = topLeft
            rect = win32gui.GetWindowRect(handle)
            LargeAppX = rect[0]
            LargeAppY = rect[1]
            MinusX, MinusY = topLeft
            x = ((LargeAppX + oldX - 50) + MinusX) + imgWidth / 2
            y = ((LargeAppY + oldY + MinusY) + imgHeight / 2)
            # pyautogui.moveTo(x,y)

            SystemFunctions.click(handle, (x, y))
            Succeeded()
        else:
            sleep(10)
            import sys
            import os
            dir_path = os.path.dirname(os.path.realpath(__file__))
            alist = dir_path.split('Elan_Tools')
            MaxImageLocation = alist[0] + r'Elan_Tools\ImageScripter\ProgramData\SystemFiles\Python\Lib\site-packages\pytank\User\UserData\Applications\Configurator\Configurator_max.png'

            handle = self.Application.GetHandle()
            templateLargeGrey = ImageGraber(handle)
            imgLarge = cv2.imread(self.ImageOfButton, 0)
            result = cv2.matchTemplate(imgLarge, templateLargeGrey, cv2.TM_CCOEFF_NORMED)
            min_val, max_val, min_loc, topLeft = cv2.minMaxLoc(result)
            # ImShow(imgLarge)
            # ImShow(templateLargeGrey)
            if max_val >= .94:
                imgHeight, imgWidth = imgLarge.shape
                x, y = topLeft
                oldX, oldY = topLeft
                x = x - 50
                topLeft = x, y
                bottomRight = (x + imgWidth, y + imgHeight)
                template = templateLargeGrey[topLeft[1]:bottomRight[1], topLeft[0]:bottomRight[0]]
                tempHeight, tempWidth = template.shape
                imgLarge = cv2.imread(MaxImageLocation, 0)
                imgHeight, imgWidth = imgLarge.shape
                result = cv2.matchTemplate(imgLarge, template, cv2.TM_CCOEFF_NORMED)
                min_val, max_val, min_loc, topLeft = cv2.minMaxLoc(result)

                SmallButtonX, SmallButtonY = topLeft
                rect = win32gui.GetWindowRect(handle)
                LargeAppX = rect[0]
                LargeAppY = rect[1]
                MinusX, MinusY = topLeft
                x = ((LargeAppX + oldX - 50) + MinusX) + imgWidth / 2
                y = ((LargeAppY + oldY + MinusY) + imgHeight / 2)
                # pyautogui.moveTo(x,y)

                SystemFunctions.click(handle, (x, y))
                Succeeded()
            else:
                print
                'MaxVal -> ' + str(max_val)
                print
                'Failed To Find'
                raise ValueError("Failed To Expand")


    def GetXY(self,amount = 15,xoffset = 0,yoffset=0,threshold = .96):
        self._application_object_.Wait()
        print('Clicking -> ', self._path_of_image_)
        for i in range(amount):
            print('Amount -> ',i,' / ',amount)
            if self._application_object_._class_name_ != "PC_Class":
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    x,y = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    #print('width',SmallWith / 2)
                    #print('height',SmallHeight / 2)
                    x = int(x + SmallWith / 2)
                    y = int(y + SmallHeight / 2)
                    break
            else:
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    SmallButtonX, SmallButtonY = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    handle = self._application_object_._get_most_likely_application_window_hande_by_tags_()
                    rect = win32gui.GetWindowRect(handle)
                    LargeAppX = rect[0]
                    LargeAppY = rect[1]
                    x = LargeAppX + SmallButtonX + SmallWith / 2
                    y = LargeAppY + SmallButtonY + SmallHeight / 2
                    break
        if result:
            x = x + xoffset
            y = y + yoffset
            print(x,',',y)
            return(x,y)
        else:
            #print(self._path_of_image_)
            raise ValueError("Cant find image -> " + self._path_of_image_)








    def RightClick(self,amount = 15,xoffset = 0,yoffset=0,threshold = .96):
        self._application_object_.Wait()
        for i in range(amount):
            if self._application_object_._class_name_ != "PC_Class":
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    x,y = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    #print('width',SmallWith / 2)
                    #print('height',SmallHeight / 2)
                    x = int(x + SmallWith / 2)
                    y = int(y + SmallHeight / 2)
                    break
            else:
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    SmallButtonX, SmallButtonY = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    handle = self._application_object_._get_most_likely_application_window_hande_by_tags_()
                    rect = win32gui.GetWindowRect(handle)
                    LargeAppX = rect[0]
                    LargeAppY = rect[1]
                    x = LargeAppX + SmallButtonX + SmallWith / 2
                    y = LargeAppY + SmallButtonY + SmallHeight / 2
                    break
        if result:
            x = x + xoffset
            y = y + yoffset
            self._application_object_._right_click_(x, y)
        else:
            #print(self._path_of_image_)
            raise ValueError("Cant find image -> " + self._path_of_image_)
    def RightClickType(self,stringToType,amount = 15,xoffset = 0,yoffset=0,threshold = .96):
        self._application_object_.Wait()
        for i in range(amount):
            if self._application_object_._class_name_ != "PC_Class":
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    x,y = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    #print('width',SmallWith / 2)
                    #print('height',SmallHeight / 2)
                    x = int(x + SmallWith / 2)
                    y = int(y + SmallHeight / 2)
                    break
            else:
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    SmallButtonX, SmallButtonY = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    handle = self._application_object_._get_most_likely_application_window_hande_by_tags_()
                    rect = win32gui.GetWindowRect(handle)
                    LargeAppX = rect[0]
                    LargeAppY = rect[1]
                    x = LargeAppX + SmallButtonX + SmallWith / 2
                    y = LargeAppY + SmallButtonY + SmallHeight / 2
                    break
        if result:
            x = x + xoffset
            y = y + yoffset
            self._application_object_._right_click_(x, y)
            pyautogui.typewrite(stringToType)
        else:
            #print(self._path_of_image_)
            raise ValueError("Cant find image -> " + self._path_of_image_)
    def ClickFast(self,amount = 15,xoffset = 0,yoffset=0,threshold = .96):
        self._application_object_.Wait()
        print('This has been depreciated, Please use "Click" instead')
        self.Click(amount,xoffset,yoffset,threshold)
    def RealClick(self,amount = 15,xoffset = 0,yoffset=0,threshold = .96):
        self._application_object_.Wait()
        print('This has been depreciated, Please use "Click" instead')
        self.Click(amount,xoffset,yoffset,threshold)
    def RightClickTypeThenPress(self,stringToType,commmand_to_press,waitbetween = 3,amount = 15,xoffset = 0,yoffset=0,threshold = .96):
        self._application_object_.Wait()
        for i in range(amount):
            if self._application_object_._class_name_ != "PC_Class":
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    x,y = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    #print('width',SmallWith / 2)
                    #print('height',SmallHeight / 2)
                    x = int(x + SmallWith / 2)
                    y = int(y + SmallHeight / 2)
                    break
            else:
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    SmallButtonX, SmallButtonY = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    handle = self._application_object_._get_most_likely_application_window_hande_by_tags_()
                    rect = win32gui.GetWindowRect(handle)
                    LargeAppX = rect[0]
                    LargeAppY = rect[1]
                    x = LargeAppX + SmallButtonX + SmallWith / 2
                    y = LargeAppY + SmallButtonY + SmallHeight / 2
                    break
        if result:
            x = x + xoffset
            y = y + yoffset
            self._application_object_._right_click_(x, y)
            pyautogui.typewrite(stringToType)
            time.sleep(waitbetween)
            pyautogui.press(commmand_to_press)
        else:
            #print(self._path_of_image_)
            raise ValueError("Cant find image -> " + self._path_of_image_)


if __name__ == "__main__":


    #############################################################CLICKING SIMPLE#################
    '''
    #######################ANDROID#########################
    from imagescripter.core.android import Android_Class
    Interface = Android_Class()
    path_of_image = r"C:\ImageScripter_2\TEMP\Android_Pics\1.PNG"
    Interface.media = Image_Class(path_of_image,Interface,.96)
    Interface.media.Click()



    #######################PC########################
    from imagescripter.core.pc import PC_Class
    Interface = PC_Class(['ELAN','Viewer:'])
    path_of_image = r"C:\ImageScripter_2\TEMP\PC_Pics\1.PNG"
    Interface.media = Image_Class(path_of_image,Interface,.96)
    Interface.media.Click()
    '''
    #######################ITP8########################
    from imagescripter.core.itp8 import ITP8_Class
    Interface = ITP8_Class(ip_address='192.168.0.105', port=22, user_name='root', password='nortek')
    path_of_image = r"C:\ImageScripter_2\TEMP\pics\2.PNG"
    Interface.media = Image_Class(path_of_image,Interface,.96)
    Interface.media.Click()
    Interface.media.Click()
    '''
   
    #######################MAC########################
    from imagescripter.core.mac import Mac_Class
    Interface = Mac_Class(ip_address='192.168.0.119', port=22, user_name='Ken', password='100hoods')
    path_of_image = r"C:\ImageScripter_2\TEMP\Mac_Pics\1.PNG"
    Interface.media = Image_Class(path_of_image, Interface, .96)
    Interface.media.Click()
    Interface.media.Click()
    

    #######################LINUX########################
    from imagescripter.core.linux import Linux_Class
    Interface = Linux_Class(ip_address='192.168.0.118', port=22, user_name='god', password='god')
    path_of_image = r"C:\ImageScripter_2\TEMP\Linux_Pics\1.PNG"
    Interface.media = Image_Class(path_of_image, Interface, .96)
    Interface.media.Click()
    Interface.media.Click()
    '''




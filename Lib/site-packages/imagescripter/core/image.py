import win32gui
import pickle
import time
import scp
import pyautogui
import shutil
from imagescripter.core.functions import Ping_Notify_If_Fail
import numpy as np
import cv2
import scipy
from imagescripter.core.image_manager import Image_Manager
try:
    from scipy.stats import itemfreq
except:
    pass
import webcolors
import os
import sys
import sys
import os
import cv2
import win32gui
import os
from imagescripter.core.variable_file_getter import Variable_File_Getter
from imagescripter.core.database_manager import Database_Manager_Class
database_location = Variable_File_Getter.getVariableFromFile('Database_Location')  # name of the sqlite database file
Database_Manager = Database_Manager_Class(database_location)
import os

On_the_Fly_Captured_Pic_File_Location = r'C:\Settings\On_The_Fly_Captured_Images.pkl'

import pickle

with open(On_the_Fly_Captured_Pic_File_Location, 'wb') as f:
    pickle.dump([], f)



try:
    with open(r"C:\Settings\Capture_Mode.txt",'r') as f:
        f.read()
except:
    with open(r"C:\Settings\Capture_Mode.txt",'w') as f:
        f.write('False')












def log_Current_action(variable):
    try:
        Variable_File_Getter.setFileFromVariable('Current_Action.txt',variable)
    except Exception as e:
        print(e)
def Get_Dom_Color_Technical(image):
    img = image
    average_color = [img[:, :, i].mean() for i in range(img.shape[-1])]
    arr = np.float32(img)
    pixels = arr.reshape((-1, 3))
    n_colors = 5
    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 200, .1)
    flags = cv2.KMEANS_RANDOM_CENTERS
    _, labels, centroids = cv2.kmeans(pixels, n_colors, None, criteria, 10, flags)
    palette = np.uint8(centroids)
    quantized = palette[labels.flatten()]
    quantized = quantized.reshape(img.shape)
    # And finally the dominant colour is the palette colour which occurs most frequently on the quantized image:
    dominant_color = palette[np.argmax(scipy.stats.itemfreq(labels)[:, -1])]
    #print(dominant_color)
    return dominant_color
def closest_colour(requested_colour):
    min_colours = {}
    for key, name in webcolors.css3_hex_to_names.items():
        r_c, g_c, b_c = webcolors.hex_to_rgb(key)
        rd = (r_c - requested_colour[0]) ** 2
        gd = (g_c - requested_colour[1]) ** 2
        bd = (b_c - requested_colour[2]) ** 2
        min_colours[(rd + gd + bd)] = name
    return min_colours[min(min_colours.keys())]
def get_colour_name(requested_colour):
    try:
        closest_name = actual_name = webcolors.rgb_to_name(requested_colour)
    except ValueError:
        closest_name = closest_colour(requested_colour)
        actual_name = None
    return actual_name, closest_name
class Image_Class():
    def __init__(self,path_of_image,appication_object,threshold):
        self._path_of_image_ = path_of_image




        #self._application_object_ = eval(appication_object)
        pickle_off = open(appication_object, "rb")
        self._application_object_ = pickle.load(pickle_off)
        self._threshold_ = threshold
    def Exists(self,threshold = .96,wait = True):
        log_Current_action("Checking if Exists")
        try:
            if wait == True:
                self._application_object_.Wait()
            self.Capture_If_Capture_Mode_Equals_True(WaitVanish = True)
            result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
            if result:
                print('Exists -> ',self._path_of_image_)
                return True
            else:
                print('Doesnt Exists -> ', self._path_of_image_)
                return False
        except Exception as e:
            print(e)
            print('Doesnt Exists -> ', self._path_of_image_)
            return False
    def get_String_From_Image(self,path_of_image):
        import base64
        with open(path_of_image, "rb") as imageFile:
            img_string = base64.b64encode(imageFile.read())
            print(img_string)
            return img_string
    def WaitContinue(self,seconds = 100,threshold = .96,wait = True):
        log_Current_action("Waiting for ")
        if wait == True:
            self._application_object_.Wait()
        self.Capture_If_Capture_Mode_Equals_True()
        print("This is just using 'Wait', needs to be worked on to enter into database")
        try:
            self.Wait(seconds,threshold)
        except:
            print("FAILLL WAITCONTINUE")
            raise ValueError('Need To Work On Wait Continue, Not ready')
            #Database_Manager.enter_test_results_into_database()
        '''
        ###########################################
        log_Current_action("Waiting Coninue For")
        if wait == True:
            self._application_object_.Wait()
        result = False
        for sec in range(seconds):
            try:
                image_of_screen_or_false = self._application_object_._get_image_of_screen_()
            except scp.SCPException:
                time.sleep(2)
                image_of_screen_or_false = self._application_object_._get_image_of_screen_()
            if image_of_screen_or_false != False:
                image_of_screen = image_of_screen_or_false
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,
                                                                                   image_of_screen, threshold)
                if result != False:
                    break
            print('Wating For ', self._path_of_image_, 'Sec->', sec, 'Total->', seconds)
            time.sleep(1)
        if result == False:
            import datetime
            import traceback
            from elan.ssh_manager import SSH_Manager_Class
            from imagescripter.core.variable_file_getter import Variable_File_Getter
            Controller_IP = Variable_File_Getter.getVariableFromFile('Controller_IP')
            Controller_Port = Variable_File_Getter.getVariableFromFile('Elan_Controller_Port')
            Controller_UserName = Variable_File_Getter.getVariableFromFile('Elan_Controller_User_Name')
            Controller_Password = Variable_File_Getter.getVariableFromFile('Elan_Controller_Password')
            self.SSH_Manager = SSH_Manager_Class(ipaddress=Controller_IP, port=Controller_Port,
                                                 username=Controller_UserName, password=Controller_Password)
            Client = 'Default'
            Index_Time = time.time()
            Index_Time_String = str(Index_Time)
            Script_Start_Time = "N/A"
            Steps = "N/A"
            now = datetime.datetime.now()
            Date = str(now.month) + '/' + str(now.day) + '/' + str(now.year)
            Script_End_Time = "N/A"
            Script_Name = "N/A"
            Pass = 'False'
            Fail = 'True'
            Skip = 'N/A'
            Controller_Build = self.SSH_Manager.get_Build()
            Error = traceback.format_exc()
            Fail_Video = 'None'
            Pass_Video = 'None'
            Last_Target_Image_Path = Variable_File_Getter.getVariableFromFile("Last_Target_Image_Location")
            Last_Templet_Image_Path = Variable_File_Getter.getVariableFromFile("Last_Templet_Image_Location")
            target_img = self.get_String_From_Image(Last_Target_Image_Path)
            templet_img = self.get_String_From_Image(Last_Templet_Image_Path)
            Error_ID = ''.join([i for i in Error if not i.isdigit()])
            self.DataBase_Manager.enter_results_into_database(Index_Time, Script_Start_Time, Steps, Date,
                                                              Script_End_Time, Script_Name, Pass, Fail, Skip,
                                                              self.Controller_Name, self.Station_Name, Controller_Build,
                                                              Error, target_img, templet_img, Error_ID, Fail_Video,
                                                              Pass_Video, Client, Index_Time_String)
        print('Found -> ', self._path_of_image_)
        '''
    def GetDominantColorClosest(self, seconds=10, threshold=.96, wait=True):
        log_Current_action("Getting Dominant Color")
        if wait == True:
            self._application_object_.Wait()
        self.Capture_If_Capture_Mode_Equals_True()
        result = False
        for sec in range(seconds):
            try:
                image_of_screen_or_false = self._application_object_._get_image_of_screen_()
            except scp.SCPException:
                time.sleep(2)
                image_of_screen_or_false = self._application_object_._get_image_of_screen_()
            if image_of_screen_or_false != False:
                image_of_screen = image_of_screen_or_false
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,                                                                     image_of_screen, threshold)
                if result != False:
                    #########################################
                    rgb = cv2.imread(self._path_of_image_)
                    dominant_color = Get_Dom_Color_Technical(rgb)
                    # [175   0   0]
                    dominant_color = str(dominant_color)
                    print(dominant_color)
                    dominant_color = dominant_color.replace(']', '')
                    dominant_color = dominant_color.replace('[', '')
                    dominant_color = dominant_color.replace('   ', ' ')
                    alist = dominant_color.split(' ')
                    alist = [x for x in alist if x]
                    print(alist)
                    r = int(alist[2])
                    g = int(alist[1])
                    b = int(alist[0])
                    requested_colour = (r, g, b)
                    actual_name, closest_name = get_colour_name(requested_colour)
                    print(closest_name)
                    return str(closest_name)
        if result == False:
            return False
    def Wait(self,seconds = 100,threshold = .96,wait = True,noprint = False):
        log_Current_action("Waiting For")
        if wait == True:
            self._application_object_.Wait()
        self.Capture_If_Capture_Mode_Equals_True()
        result = False
        for sec in range(seconds):
            if noprint == False:
                print(sec)
            try:
                image_of_screen_or_false = self._application_object_._get_image_of_screen_()
            except scp.SCPException:
                time.sleep(2)
                image_of_screen_or_false = self._application_object_._get_image_of_screen_()
            if image_of_screen_or_false != False:
                image_of_screen = image_of_screen_or_false
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,image_of_screen, threshold)
                if result != False:
                    break
            print('Wating For ',self._path_of_image_,'Sec->',sec,'Total->',seconds)
            time.sleep(1)
        if result == False:
            raise ValueError("Image not Found->", self._path_of_image_)
        print('Found -> ',self._path_of_image_)
        '''
           
            if image_of_screen_or_false != False:
                image_of_screen = image_of_screen_or_false
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,image_of_screen,threshold)
                break
            else:
                time.sleep(1)
        #if not result:
        #        print("Failed Looking For -> ", self._path_of_image_)
        #        raise ValueError("Image not Found->",self._path_of_image_)
        '''
    def WaitVanish(self,seconds = 100,threshold = .96,wait = True):
        log_Current_action("Waiting To Vanish")
        if wait == True:
            self._application_object_.Wait()
        self.Capture_If_Capture_Mode_Equals_True(WaitVanish = True)
        print("Waiting For Vanish")
        try:
            for i in range(seconds):
                print(seconds)
                seconds -= 1
                try:
                    result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                except shutil.SpecialFileError as e:
                    result = None
                if not result:
                    print("Image Vanished")
                    break
                time.sleep(1)
            if result:
                    raise ValueError("Image did not disappear")
        except TypeError as e:
            print(e)
            print("Image Vanished")
    def SetThreshold(self,x):
        print("Set Threshold Does Not Work Right Now, Need to program")
    def take_screen_shot_of_desktop(self):
        print("Taking screen shot")
        image = pyautogui.screenshot()
        image = cv2.cvtColor(np.array(image), cv2.COLOR_RGB2BGR)
        cv2.imwrite(r"C:\Settings\Last_Target_Image.png", image)
    def Max(self):
        self.Capture_If_Capture_Mode_Equals_True()
        Max = r"C:\ImageScripter_2\Lib\site-packages\imagescripter\core\max.png"
        Min = r"C:\Users\Automation3\Desktop\min.png"
        Templet = r"C:\Users\Automation3\Desktop\templet.png"
        Image = r"C:\Users\Automation3\Desktop\systemlogs.png"
        #TEMPLET = cv2.imread(Templet, 0)
        #TEMPLET = self._application_object_._get_image_of_screen_()
        TEMPLET = cv2.imread(self._application_object_._get_image_of_screen_(), 0)
        IMAGE = cv2.imread(self._path_of_image_, 0)
        result = cv2.matchTemplate(IMAGE, TEMPLET, cv2.TM_CCOEFF_NORMED)
        min_val, max_val, min_loc, topLeft = cv2.minMaxLoc(result)
        if max_val >= .94:
            imgHeight, imgWidth = IMAGE.shape
            x, y = topLeft
            oldX, oldY = topLeft
            x = x - 50
            topLeft = x, y
            bottomRight = (x + imgWidth, y + imgHeight)
            template = TEMPLET[topLeft[1]:bottomRight[1], topLeft[0]:bottomRight[0]]
            tempHeight, tempWidth = template.shape
            IMAGE = cv2.imread(Max, 0)
            imgHeight, imgWidth = IMAGE.shape
            result = cv2.matchTemplate(IMAGE, template, cv2.TM_CCOEFF_NORMED)
            min_val, max_val, min_loc, topLeft = cv2.minMaxLoc(result)
            SmallButtonX, SmallButtonY = topLeft
            handle = self._application_object_._get_most_likely_application_window_hande_by_tags_()
            rect = win32gui.GetWindowRect(handle)
            LargeAppX = rect[0]
            LargeAppY = rect[1]
            MinusX, MinusY = topLeft
            x = ((LargeAppX + oldX - 50) + MinusX) + imgWidth / 2
            y = ((LargeAppY + oldY + MinusY) + imgHeight / 2)
            self._application_object_._click_(x, y)
            self._Update_last_image_()
            #pyautogui.moveTo(x,y)
            #SystemFunctions.click(handle, (x, y))
    def Min(self):
        self.Capture_If_Capture_Mode_Equals_True()
        #Max = r"C:\Users\Automation3\Desktop\max.png"
        Min = r"C:\ImageScripter_2\Lib\site-packages\imagescripter\core\min.png"
        Templet = r"C:\Users\Automation3\Desktop\templet.png"
        Image = r"C:\Users\Automation3\Desktop\systemlogs.png"
        #TEMPLET = cv2.imread(Templet, 0)
        #TEMPLET = self._application_object_._get_image_of_screen_()
        TEMPLET = cv2.imread(self._application_object_._get_image_of_screen_(), 0)
        IMAGE = cv2.imread(self._path_of_image_, 0)
        result = cv2.matchTemplate(IMAGE, TEMPLET, cv2.TM_CCOEFF_NORMED)
        min_val, max_val, min_loc, topLeft = cv2.minMaxLoc(result)
        if max_val >= .94:
            imgHeight, imgWidth = IMAGE.shape
            x, y = topLeft
            oldX, oldY = topLeft
            x = x - 50
            topLeft = x, y
            bottomRight = (x + imgWidth, y + imgHeight)
            template = TEMPLET[topLeft[1]:bottomRight[1], topLeft[0]:bottomRight[0]]
            tempHeight, tempWidth = template.shape
            IMAGE = cv2.imread(Min, 0)
            imgHeight, imgWidth = IMAGE.shape
            result = cv2.matchTemplate(IMAGE, template, cv2.TM_CCOEFF_NORMED)
            min_val, max_val, min_loc, topLeft = cv2.minMaxLoc(result)
            SmallButtonX, SmallButtonY = topLeft
            handle = self._application_object_._get_most_likely_application_window_hande_by_tags_()
            rect = win32gui.GetWindowRect(handle)
            LargeAppX = rect[0]
            LargeAppY = rect[1]
            MinusX, MinusY = topLeft
            x = ((LargeAppX + oldX - 50) + MinusX) + imgWidth / 2
            y = ((LargeAppY + oldY + MinusY) + imgHeight / 2)
            #pyautogui.moveTo(x,y)
            self._application_object_._click_(x, y)
            self._Update_last_image_()
            #SystemFunctions.click(handle, (x, y))
    def PressAndHold(self,seconds = 5,amount = 15,xoffset = 0,yoffset=0,threshold = .96):
        self._application_object_.Wait()
        self.Capture_If_Capture_Mode_Equals_True()
        for i in range(amount):
            print('Amount -> ',i,' / ',amount)
            if self._application_object_._class_name_ != "PC_Class":
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    x,y = result
                    handle = self._application_object_._get_most_likely_application_window_hande_by_tags_()
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    #print('width',SmallWith / 2)
                    #print('height',SmallHeight / 2)
                    x = int(x + SmallWith / 2)
                    y = int(y + SmallHeight / 2)
                    break
            else:
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    SmallButtonX, SmallButtonY = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    handle = self._application_object_._get_most_likely_application_window_hande_by_tags_()
                    rect = win32gui.GetWindowRect(handle)
                    LargeAppX = rect[0]
                    LargeAppY = rect[1]
                    x = rect[0]
                    y = rect[1]
                    w = rect[2] - x
                    h = rect[3] - y
                    x = y + LargeAppX + SmallButtonX + SmallWith / 2
                    y = x + LargeAppY + SmallButtonY + SmallHeight / 2
                    break
        if result:
            x = x + xoffset
            y = y + yoffset
            self._application_object_._move_to_(x,y)
            self._application_object_._left_mouse_down_()
            for i in range(seconds):
                print(i,'/',seconds)
                time.sleep(i)
            self._application_object_._left_mouse_up_()
            self._Update_last_image_()
        else:
            #print(self._path_of_image_)
            raise ValueError("Cant find image -> " + self._path_of_image_)


    def PressHoldAndWait(self,image,seconds = 10,amount = 15,xoffset = 0,yoffset=0,threshold = .96):
        self._application_object_.Wait()
        self.Capture_If_Capture_Mode_Equals_True()
        for i in range(amount):
            print('Amount -> ',i,' / ',amount)
            if self._application_object_._class_name_ != "PC_Class":
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    x,y = result
                    handle = self._application_object_._get_most_likely_application_window_hande_by_tags_()
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    #print('width',SmallWith / 2)
                    #print('height',SmallHeight / 2)
                    x = int(x + SmallWith / 2)
                    y = int(y + SmallHeight / 2)
                    break
            else:
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    SmallButtonX, SmallButtonY = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    handle = self._application_object_._get_most_likely_application_window_hande_by_tags_()
                    rect = win32gui.GetWindowRect(handle)
                    LargeAppX = rect[0]
                    LargeAppY = rect[1]
                    x = rect[0]
                    y = rect[1]
                    w = rect[2] - x
                    h = rect[3] - y
                    x = y + LargeAppX + SmallButtonX + SmallWith / 2
                    y = x + LargeAppY + SmallButtonY + SmallHeight / 2
                    break
        if result:
            x = x + xoffset
            y = y + yoffset
            self._application_object_._move_to_(x,y)
            self._application_object_._left_mouse_down_()
            image.Wait(seconds = seconds)


            self._application_object_._left_mouse_up_()
            self._Update_last_image_()
        else:
            #print(self._path_of_image_)
            raise ValueError("Cant find image -> " + self._path_of_image_)







    def ClickDouble(self,amount = 15,xoffset = 0,yoffset=0,threshold = .96,wait = True):
        log_Current_action("Clicking ")
        if wait == True:
            self._application_object_.Wait()
        else:
            pass
        self.Capture_If_Capture_Mode_Equals_True()
        for i in range(amount):
            print('Amount -> ',i,' / ',amount)
            if self._application_object_.classtype != "PC_Class":
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    x,y = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    #print('width',SmallWith / 2)
                    #print('height',SmallHeight / 2)
                    x = int(x + SmallWith / 2)
                    y = int(y + SmallHeight / 2)
                    break
                else:
                    print(self._path_of_image_)
            else:
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    SmallButtonX, SmallButtonY = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    handle = self._application_object_._get_most_likely_application_window_hande_by_tags_()
                    rect = win32gui.GetWindowRect(handle)
                    LargeAppX = rect[0]
                    LargeAppY = rect[1]
                    w = rect[2] - LargeAppX
                    h = rect[3] - LargeAppY
                    x = LargeAppX + SmallButtonX + SmallWith / 2
                    y = LargeAppY + SmallButtonY + SmallHeight / 2
                    break
                else:
                    print(self._path_of_image_)
        if result:
            x = x + xoffset
            y = y + yoffset
            self._application_object_._click_(x, y)
            self._application_object_._click_(x, y)
            self._Update_last_image_()
        else:
            #print(self._path_of_image_)
            raise ValueError("Cant find image -> " + self._path_of_image_)



    def ClickRepeatNewOffset(self, amount=15, xoffset=0, yoffset=0,xoffset2=0, yoffset2=0,threshold=.96, wait=True, after_image=True, times=1,seconds = 1):
        log_Current_action("Click Reapeat New Offset ")
        if wait == True:
            self._application_object_.Wait()
        else:
            pass
        self.Capture_If_Capture_Mode_Equals_True()
        for i in range(amount):
            if i != 0:
                print('Amount -> ', i, ' / ', amount)
            if self._application_object_.classtype != "PC_Class":
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,
                                                                                   self._application_object_._get_image_of_screen_(),
                                                                                   threshold)
                if result:
                    x, y = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(
                        self._path_of_image_)
                    # print('width',SmallWith / 2)
                    # print('height',SmallHeight / 2)
                    x = int(x + SmallWith / 2)
                    y = int(y + SmallHeight / 2)
                    break
                else:
                    print(self._path_of_image_)
            else:
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,
                                                                                   self._application_object_._get_image_of_screen_(),
                                                                                   threshold)
                if result:
                    SmallButtonX, SmallButtonY = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(
                        self._path_of_image_)
                    handle = self._application_object_._get_most_likely_application_window_hande_by_tags_()
                    rect = win32gui.GetWindowRect(handle)
                    LargeAppX = rect[0]
                    LargeAppY = rect[1]
                    w = rect[2] - LargeAppX
                    h = rect[3] - LargeAppY
                    x = LargeAppX + SmallButtonX + SmallWith / 2
                    y = LargeAppY + SmallButtonY + SmallHeight / 2
                    break
                else:
                    print(self._path_of_image_)
        if result:
                self._application_object_._click_(x + xoffset, y + yoffset)
                time.sleep(seconds)
                for i in range(times):
                    time.sleep(seconds)
                    print(i, ' / ', times)
                    self._application_object_._click_(x + xoffset2, y + yoffset2)
                if after_image == True:
                    self._Update_last_image_()
        else:
            # print(self._path_of_image_)
            raise ValueError("Cant find image -> " + self._path_of_image_)




















    def Click(self,seconds = 1, amount=15, xoffset=0, yoffset=0, threshold=.96, wait=True, after_image=True, times=0):
        log_Current_action("Clicking ")
        if wait == True:
            self._application_object_.Wait()
        else:
            pass
        self.Capture_If_Capture_Mode_Equals_True()
        for i in range(amount):
            if i != 0:
                print('Amount -> ', i, ' / ', amount)
            if self._application_object_.classtype != "PC_Class":
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,
                                                                                   self._application_object_._get_image_of_screen_(),
                                                                                   threshold)
                if result:
                    x, y = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(
                        self._path_of_image_)
                    # print('width',SmallWith / 2)
                    # print('height',SmallHeight / 2)
                    x = int(x + SmallWith / 2)
                    y = int(y + SmallHeight / 2)
                    break
                else:
                    print(self._path_of_image_)
            else:
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,
                                                                                   self._application_object_._get_image_of_screen_(),
                                                                                   threshold)
                if result:
                    SmallButtonX, SmallButtonY = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(
                        self._path_of_image_)
                    handle = self._application_object_._get_most_likely_application_window_hande_by_tags_()
                    rect = win32gui.GetWindowRect(handle)
                    LargeAppX = rect[0]
                    LargeAppY = rect[1]
                    w = rect[2] - LargeAppX
                    h = rect[3] - LargeAppY
                    x = LargeAppX + SmallButtonX + SmallWith / 2
                    y = LargeAppY + SmallButtonY + SmallHeight / 2
                    break
                else:
                    print(self._path_of_image_)
        if result:
            x = x + xoffset
            y = y + yoffset
            if times == 0:
                self._application_object_._click_(x, y)
            else:
                for i in range(times):
                    print(i, ' / ', times)
                    time.sleep(seconds)
                    self._application_object_._click_(x, y)
            if after_image == True:
                self._Update_last_image_()
        else:
            # print(self._path_of_image_)
            raise ValueError("Cant find image -> " + self._path_of_image_)




    def _Update_last_image_(self):
        try:
            time.sleep(1)
            newimage = self._application_object_._get_image_of_screen_()
            Image_Manager.Update_Templet_With_Image_Path(newimage)
        except Exception as e:
            print(e)
            print(522)


    def Capture_If_Capture_Mode_Equals_True(self,WaitVanish = False):
        CAPTURE_MODE = Variable_File_Getter.getVariableFromFile('Capture_Mode')

        if CAPTURE_MODE == 'True' and WaitVanish == False:
                #print('Capture mode is True')
                with open(On_the_Fly_Captured_Pic_File_Location, 'rb') as f:
                    #print('Reading Pickle')
                    List_Of_Images = pickle.load(f)
                    #print('List_of_images',List_Of_Images)
                if self._path_of_image_ in List_Of_Images:
                    #print('Image in List')
                    pass
                else:
                    #print("Image not in List")
                    List_Of_Images.append(self._path_of_image_)
                    with open(On_the_Fly_Captured_Pic_File_Location, 'wb') as f:
                        pickle.dump(List_Of_Images, f)

                    result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,
                                                                                   self._application_object_._get_image_of_screen_(attempts = 1),
                                                                                   threshold = .96)
                    if not result:
                        print("Capture Start")
                        import subprocess
                        #########################################
                        IP = self._application_object_.Get_IP()
                        if IP != None:
                            Pass_or_Fail = Ping_Notify_If_Fail(IP)
                            if Pass_or_Fail != False:
                                self._Update_last_image_()
                            else:
                                text = IP + ' ' + 'is not responding to pings!'
                                raise ValueError(text)
                        #########################################
                        self._Update_last_image_()
                        import subprocess
                        #subprocess.Popen(r"C:\ImageScripter_2\python.exe C:\ImageScripter_2\Lib\site-packages\Script_Writer\snipping_tool.py",shell=True)
                        #subprocess.Popen(r"C:\ImageScripter_2\python.exe C:\ImageScripter_2\Lib\site-packages\Script_Writer\diplay_image_for_capture.py")
                        #s.system(r"C:\ImageScripter_2\python.exe C:\ImageScripter_2\Lib\site-packages\Script_Writer\snipping_tool_for_converter.py")
                        App = 'ViewerTest'
                        path = self._path_of_image_
                        os.system(r"C:\ImageScripter_2\python.exe C:\ImageScripter_2\Lib\site-packages\Script_Writer\Image_Converter.py " + App + ' ' + path)
                        #os.system(r"C:\ImageScripter_2\python.exe C:\ImageScripter_2\Lib\site-packages\Script_Writer\diplay_image_for_capture.py ViewerTest " + self._path_of_image_)
                        ##########MIGHT NOT NEED###############
                        #new_image = "C:\ImageScripter_2\Lib\site-packages\Script_Writer\capture.png"
                        #os.remove(self._path_of_image_)
                        #shutil.move(new_image,self._path_of_image_)
                        #os.system(r"C:\ImageScripter_2\python.exe C:\ImageScripter_2\Lib\site-packages\Script_Writer\diplay_image_for_capture.py")
                        #print("Capture End")

    def Hover(self,amount = 15,xoffset = 0,yoffset=0,threshold = .96,wait = True,after_image = True):
        log_Current_action("Hover ")
        if wait == True:
            self._application_object_.Wait()
        else:
            pass
        self.Capture_If_Capture_Mode_Equals_True()

        for i in range(amount):
            print('Amount -> ',i,' / ',amount)
            if self._application_object_.classtype != "PC_Class":
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    x,y = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    #print('width',SmallWith / 2)
                    #print('height',SmallHeight / 2)
                    x = int(x + SmallWith / 2)
                    y = int(y + SmallHeight / 2)
                    break
                else:
                    print(self._path_of_image_)
            else:
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    SmallButtonX, SmallButtonY = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    handle = self._application_object_._get_most_likely_application_window_hande_by_tags_()
                    rect = win32gui.GetWindowRect(handle)
                    LargeAppX = rect[0]
                    LargeAppY = rect[1]
                    w = rect[2] - LargeAppX
                    h = rect[3] - LargeAppY
                    x = LargeAppX + SmallButtonX + SmallWith / 2
                    y = LargeAppY + SmallButtonY + SmallHeight / 2
                    break
                else:
                    print(self._path_of_image_)
        if result:
            x = x + xoffset
            y = y + yoffset
            self._application_object_._hover_(x, y)
            if after_image == True:
                self._Update_last_image_()
        else:
            #print(self._path_of_image_)
            raise ValueError("Cant find image -> " + self._path_of_image_)


    def ClickXY(self,x,y):
        log_Current_action("Clicking X Y")
        self._application_object_._click_(x, y)
        self._Update_last_image_()
    def GetXY(self,amount = 15,xoffset = 0,yoffset=0,threshold = .96):
        log_Current_action("Getting X Y")
        self._application_object_.Wait()
        self.Capture_If_Capture_Mode_Equals_True()
        print('Clicking -> ', self._path_of_image_)
        for i in range(amount):
            print('Amount -> ',i,' / ',amount)
            if self._application_object_._class_name_ != "PC_Class":
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    x,y = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    #print('width',SmallWith / 2)
                    #print('height',SmallHeight / 2)
                    x = int(x + SmallWith / 2)
                    y = int(y + SmallHeight / 2)
                    break
            else:
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    SmallButtonX, SmallButtonY = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    handle = self._application_object_._get_most_likely_application_window_hande_by_tags_()
                    rect = win32gui.GetWindowRect(handle)
                    LargeAppX = rect[0]
                    LargeAppY = rect[1]
                    x = LargeAppX + SmallButtonX + SmallWith / 2
                    y = LargeAppY + SmallButtonY + SmallHeight / 2
                    break
        if result:
            x = x + xoffset
            y = y + yoffset
            print(x,',',y)
            return(x,y)
        else:
            #print(self._path_of_image_)
            raise ValueError("Cant find image -> " + self._path_of_image_)
    def RightClick(self,amount = 15,xoffset = 0,yoffset=0,threshold = .96):
        log_Current_action("Right Clicking ")
        self._application_object_.Wait()
        self.Capture_If_Capture_Mode_Equals_True()
        for i in range(amount):
            if self._application_object_._class_name_ != "PC_Class":
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    x,y = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    #print('width',SmallWith / 2)
                    #print('height',SmallHeight / 2)
                    x = int(x + SmallWith / 2)
                    y = int(y + SmallHeight / 2)
                    break
            else:
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    SmallButtonX, SmallButtonY = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    handle = self._application_object_._get_most_likely_application_window_hande_by_tags_()
                    rect = win32gui.GetWindowRect(handle)
                    LargeAppX = rect[0]
                    LargeAppY = rect[1]
                    x = LargeAppX + SmallButtonX + SmallWith / 2
                    y = LargeAppY + SmallButtonY + SmallHeight / 2
                    break
        if result:
            x = x + xoffset
            y = y + yoffset
            self._application_object_._right_click_(x, y)
            self._Update_last_image_()
        else:
            #print(self._path_of_image_)
            raise ValueError("Cant find image -> " + self._path_of_image_)
    def RightClickType(self,stringToType,amount = 15,xoffset = 0,yoffset=0,threshold = .96):
        log_Current_action("Right Clicking Then Type")
        self._application_object_.Wait()
        self.Capture_If_Capture_Mode_Equals_True()
        for i in range(amount):
            if self._application_object_._class_name_ != "PC_Class":
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    x,y = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    #print('width',SmallWith / 2)
                    #print('height',SmallHeight / 2)
                    x = int(x + SmallWith / 2)
                    y = int(y + SmallHeight / 2)
                    break
            else:
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    SmallButtonX, SmallButtonY = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    handle = self._application_object_._get_most_likely_application_window_hande_by_tags_()
                    rect = win32gui.GetWindowRect(handle)
                    LargeAppX = rect[0]
                    LargeAppY = rect[1]
                    x = LargeAppX + SmallButtonX + SmallWith / 2
                    y = LargeAppY + SmallButtonY + SmallHeight / 2
                    break
        if result:
            x = x + xoffset
            y = y + yoffset
            self._application_object_._right_click_(x, y)
            pyautogui.typewrite(stringToType)
            self._Update_last_image_()
        else:
            #print(self._path_of_image_)
            raise ValueError("Cant find image -> " + self._path_of_image_)
    def ClickFast(self,amount = 15,xoffset = 0,yoffset=0,threshold = .96):
        log_Current_action("Clicking Fast")
        self._application_object_.Wait()
        print('This has been depreciated, Please use "Click" instead')
        self.Click(amount,xoffset,yoffset,threshold)
    def RealClick(self,amount = 15,xoffset = 0,yoffset=0,threshold = .96):
        log_Current_action("Real Clicking")
        self._application_object_.Wait()
        print('This has been depreciated, Please use "Click" instead')
        self.Click(amount,xoffset,yoffset,threshold)
    def RightClickTypeThenPress(self,stringToType,commmand_to_press,waitbetween = 3,amount = 15,xoffset = 0,yoffset=0,threshold = .96):
        log_Current_action("Right Clicking Then Type Then Press")
        self._application_object_.Wait()
        self.Capture_If_Capture_Mode_Equals_True()
        for i in range(amount):
            if self._application_object_._class_name_ != "PC_Class":
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    x,y = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    #print('width',SmallWith / 2)
                    #print('height',SmallHeight / 2)
                    x = int(x + SmallWith / 2)
                    y = int(y + SmallHeight / 2)
                    break
            else:
                result = self._application_object_._get_location_of_image_in_image(self._path_of_image_,self._application_object_._get_image_of_screen_(),threshold)
                if result:
                    SmallButtonX, SmallButtonY = result
                    SmallWith, SmallHeight = self._application_object_._get_an_image_Width_and_height_(self._path_of_image_)
                    handle = self._application_object_._get_most_likely_application_window_hande_by_tags_()
                    rect = win32gui.GetWindowRect(handle)
                    LargeAppX = rect[0]
                    LargeAppY = rect[1]
                    x = LargeAppX + SmallButtonX + SmallWith / 2
                    y = LargeAppY + SmallButtonY + SmallHeight / 2
                    break
        if result:
            x = x + xoffset
            y = y + yoffset
            self._application_object_._right_click_(x, y)
            pyautogui.typewrite(stringToType)
            time.sleep(waitbetween)
            pyautogui.press(commmand_to_press)
            self._Update_last_image_()
        else:
            #print(self._path_of_image_)
            raise ValueError("Cant find image -> " + self._path_of_image_)
if __name__ == "__main__":
    #############################################################CLICKING SIMPLE#################
    '''
    #######################ANDROID#########################
    from imagescripter.core.android import Android_Class
    Interface = Android_Class()
    path_of_image = r"C:\ImageScripter_2\TEMP\Android_Pics\1.PNG"
    Interface.media = Image_Class(path_of_image,Interface,.96)
    Interface.media.Click()
    #######################PC########################
    from imagescripter.core.pc import PC_Class
    Interface = PC_Class(['ELAN','Viewer:'])
    path_of_image = r"C:\ImageScripter_2\TEMP\PC_Pics\1.PNG"
    Interface.media = Image_Class(path_of_image,Interface,.96)
    Interface.media.Click()
    '''
    #######################ITP8########################
    from imagescripter.core.itp8 import ITP8_Class
    Interface = ITP8_Class(ip_address='192.168.0.105', port=22, user_name='root', password='nortek')
    path_of_image = r"C:\ImageScripter_2\TEMP\pics\2.PNG"
    Interface.media = Image_Class(path_of_image,Interface,.96)
    Interface.media.Click()
    Interface.media.Click()
    '''
   
    #######################MAC########################
    from imagescripter.core.mac import Mac_Class
    Interface = Mac_Class(ip_address='192.168.0.119', port=22, user_name='Ken', password='100hoods')
    path_of_image = r"C:\ImageScripter_2\TEMP\Mac_Pics\1.PNG"
    Interface.media = Image_Class(path_of_image, Interface, .96)
    Interface.media.Click()
    Interface.media.Click()
    
    #######################LINUX########################
    from imagescripter.core.linux import Linux_Class
    Interface = Linux_Class(ip_address='192.168.0.118', port=22, user_name='god', password='god')
    path_of_image = r"C:\ImageScripter_2\TEMP\Linux_Pics\1.PNG"
    Interface.media = Image_Class(path_of_image, Interface, .96)
    Interface.media.Click()
    Interface.media.Click()
    '''
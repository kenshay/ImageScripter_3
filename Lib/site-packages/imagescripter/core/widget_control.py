import pywinauto
import win32con
import win32gui
import pywintypes
import os
import win32api
import ctypes
from win32con import PAGE_READWRITE, MEM_COMMIT, MEM_RESERVE, MEM_RELEASE,PROCESS_ALL_ACCESS
from commctrl import LVM_GETITEMTEXT, LVM_GETITEMCOUNT
import struct
import ctypes
import array
import win32api
import win32gui
import time
from time import sleep

#https://pywinauto.readthedocs.io/en/latest/code/pywinauto.controls.uia_controls.html


GetWindowThreadProcessId = ctypes.windll.user32.GetWindowThreadProcessId
VirtualAllocEx = ctypes.windll.kernel32.VirtualAllocEx
VirtualFreeEx = ctypes.windll.kernel32.VirtualFreeEx
OpenProcess = ctypes.windll.kernel32.OpenProcess
WriteProcessMemory = ctypes.windll.kernel32.WriteProcessMemory
ReadProcessMemory = ctypes.windll.kernel32.ReadProcessMemory
memcpy = ctypes.cdll.msvcrt.memcpy
def _buildWinLong(high, low):
    '''Build a windows long parameter from high and low words.
    See http://support.microsoft.com/support/kb/articles/q189/1/70.asp
    '''
    # return ((high << 16) | low)
    return int(struct.unpack('>L',
                             struct.pack('>2H',
                                         high,
                                         low)) [0])
def _sendNotifyMessage(hwnd, nofifyMessage):
    '''Send a notify message to a control.'''
    win32gui.SendMessage(win32gui.GetParent(hwnd),
                         win32con.WM_COMMAND,
                         _buildWinLong(nofifyMessage,
                                       win32api.GetWindowLong(hwnd,
                                                              win32con.GWL_ID)),
                         hwnd)
def selectComboboxItem(hwnd, item):
    '''Selects a specified item in a Combo box control.

    Arguments:
    hwnd            Window handle of the required combo box.
    item            The reqired item. Either an index, of the text of the
                    required item.

    Usage example:  fontComboItems = getComboboxItems(fontCombo)
                    selectComboboxItem(fontCombo,
                                       random.choice(fontComboItems))
    '''
    try:  # item is an index Use this to select
        0 + item
        win32gui.SendMessage(hwnd, win32con.CB_SETCURSEL, item, 0)
        _sendNotifyMessage(hwnd, win32con.CBN_SELCHANGE)
    except TypeError:  # Item is a string - find the index, and use that
        items = getComboboxItems(hwnd)
        itemIndex = items.index(item)
        selectComboboxItem(hwnd, itemIndex)
        return itemIndex
def Say(x):
    pass
def setEditText(hwnd, text, append=False):
    try:
        text + ''
        text = [text]
    except TypeError:
        pass
    if append:
        win32gui.SendMessage(hwnd,win32con.EM_SETSEL,-1,0)
    else:
        win32gui.SendMessage(hwnd,win32con.EM_SETSEL,0,-1)
    win32gui.SendMessage(hwnd,win32con.EM_REPLACESEL,True,os.linesep.join(text))
def EnumChildWindowsCustom(currentHwnd, _windowEnumerationHandler, childWindows,Application = None):
        win32gui.EnumChildWindows(currentHwnd, _windowEnumerationHandler, childWindows)
def readListViewItems(hwnd, column_index=0):
    # Allocate virtual memory inside target process
    pid = ctypes.create_string_buffer(4)
    p_pid = ctypes.addressof(pid)
    GetWindowThreadProcessId(hwnd, p_pid) # process owning the given hwnd
    hProcHnd = OpenProcess(PROCESS_ALL_ACCESS, False, struct.unpack("i",pid)[0])
    pLVI = VirtualAllocEx(hProcHnd, 0, 4096, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE)
    pBuffer = VirtualAllocEx(hProcHnd, 0, 4096, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE)
    # Prepare an LVITEM record and write it to target process memory
    lvitem_str = struct.pack('iiiiiiiii', *[0,0,column_index,0,0,pBuffer,4096,0,0])
    lvitem_buffer = ctypes.create_string_buffer(lvitem_str)
    copied = ctypes.create_string_buffer(4)
    p_copied = ctypes.addressof(copied)
    WriteProcessMemory(hProcHnd, pLVI, ctypes.addressof(lvitem_buffer), ctypes.sizeof(lvitem_buffer), p_copied)

    # iterate items in the SysListView32 control
    num_items = win32gui.SendMessage(hwnd, LVM_GETITEMCOUNT)
    item_texts = []
    for item_index in range(num_items):
        win32gui.SendMessage(hwnd, LVM_GETITEMTEXT, item_index, pLVI)
        target_buff = ctypes.create_string_buffer(4096)
        ReadProcessMemory(hProcHnd, pBuffer, ctypes.addressof(target_buff), 4096, p_copied)
        item_texts.append(target_buff.value)

    VirtualFreeEx(hProcHnd, pBuffer, 0, MEM_RELEASE)
    VirtualFreeEx(hProcHnd, pLVI, 0, MEM_RELEASE)
    win32api.CloseHandle(hProcHnd)
    return item_texts
def SendKeys(hwnd, msg):
    x=300
    y=300
    lParam = y <<15 | x
    win32api.PostMessage(hwnd,win32con.WM_LBUTTONDOWN, win32con.MK_LBUTTON, lParam)
    win32api.PostMessage(hwnd,win32con.WM_LBUTTONUP, 0, lParam)
    for c in msg:
        if c == "\n":
            win32api.PostMessage(hwnd, win32con.WM_KEYDOWN, win32con.VK_RETURN, 0)
            win32api.PostMessage(hwnd, win32con.WM_KEYUP, win32con.VK_RETURN, 0)
            win32api.PostMessage(hwnd, win32con.WM_CHAR, ord(c), 0)
        else:
            win32api.PostMessage(hwnd, win32con.WM_CHAR, ord(c), 0)
            import win32ui
            a = win32ui.CreateWindowFromHandle(hwnd)
def _getMultipleWindowValues(hwnd, getCountMessage, getValueMessage):
    '''A common pattern in the Win32 API is that in order to retrieve a
    series of values, you use one message to get a count of available
    items, and another to retrieve them. This internal utility function
    performs the common processing for this pattern.

    Arguments:
    hwnd                Window handle for the window for which items should be
                        retrieved.
    getCountMessage     Item count message.
    getValueMessage     Value retrieval message.

    Returns:            Retrieved items.'''
    result = []

    VALUE_LENGTH = 256
    bufferlength_int = struct.pack('i', VALUE_LENGTH)  # This is a C style int.

    valuecount = win32gui.SendMessage(hwnd, getCountMessage, 0, 0)
    for itemIndex in range(valuecount):
        valuebuffer = array.array('c',
                                  bufferlength_int +
                                  " " * (VALUE_LENGTH - len(bufferlength_int)))
        valueLength = win32gui.SendMessage(hwnd,
                                           getValueMessage,
                                           itemIndex,
                                           valuebuffer)
        result.append(valuebuffer.tostring()[:valueLength])
    return result
def getComboboxItems(hwnd):
    '''Returns the items in a combo box control.

    Arguments:
    hwnd            Window handle for the combo box.

    Returns:        Combo box items.

    Usage example:  fontCombo = findControl(fontDialog, wantedClass="ComboBox")
                    fontComboItems = getComboboxItems(fontCombo)
    '''

    return _getMultipleWindowValues(hwnd,
                                    getCountMessage=win32con.CB_GETCOUNT,
                                    getValueMessage=win32con.CB_GETLBTEXT)
class ListView_Class():
    def __init__(self, ApplicationObject):
        self.ListViewList = []
        self.Application = ApplicationObject
    def HandlerChild(self, hwnd, Extra):
        if win32gui.GetClassName(hwnd) == 'SysListView32':
            self.ListViewList.append(hwnd)
    def GetSelectionOLD(self, number):
        print('Get Selection')
        self.Application.Wait()
        hwnd = self.Application._get_most_likely_application_window_hande_by_tags_()
        self.ListViewList = []
        EnumChildWindowsCustom(hwnd, self.HandlerChild, None, self.Application)
        #EnumChildWindowsCustom(hwnd, self.HandlerChild, None, self.Application)
        print('##########')
        print(self.ListViewList[number])
        print(self.ListViewList)
        print('##########')
        items = readListViewItems(self.ListViewList[number])
        print('Items -> ' + str(items))
        # self.ListViewList = []
        return items
    def Show(self):
        print("Show")
        self.Application.Wait()
        hwnd = self.Application._get_most_likely_application_window_hande_by_tags_()
        EnumChildWindowsCustom(hwnd, self.HandlerChild, None, self.Application)
        list = []
        for i in self.ListViewList:
            rect = win32gui.GetWindowRect(i)
            x = rect[0]
            y = rect[1]
            w = rect[2] - x
            h = rect[3] - y
            rect = (x, y, w, h)
            list.append(rect)
        self.ListViewList = []
    def _SendKeys_(self, number, text):
        print('Send Keys')
        self.Application.Wait()
        self.ListViewList = []
        hwnd = self.Application._get_most_likely_application_window_hande_by_tags_()
        try:
            EnumChildWindowsCustom(hwnd, self.HandlerChild, None, self.Application)
        except pywintypes.error:
            string = "Failed To Find -> " + 'ListView' + " Error #23456"
            raise ValueError(string)
        try:
            sleep(.10)
            EnumChildWindowsCustom(hwnd, self.HandlerChild, None, self.Application)
        except pywintypes.error:
            string = "Failed To Find -> " + 'ListView' + " Error #23456"
            raise ValueError(string)
        SendKeys(self.ListViewList[number], text)
    def Select(self, number, string_or_int):
        if isinstance(string_or_int, str):
            try:
                print('Select')
                self.Application.Wait()
                self.ListViewList = []
                hwnd = self.Application._get_most_likely_application_window_hande_by_tags_()
                EnumChildWindowsCustom(hwnd, self.HandlerChild, None, self.Application)
                a = pywinauto.controls.common_controls.ListViewWrapper(self.ListViewList[number])
                a.get_item(0).select()
                SendKeys(self.ListViewList[number],string_or_int)
            except:
                sleep(4)
                print('Select')
                self.Application.Wait()
                self.ListViewList = []
                hwnd = self.Application._get_most_likely_application_window_hande_by_tags_()
                EnumChildWindowsCustom(hwnd, self.HandlerChild, None, self.Application)
                a = pywinauto.controls.common_controls.ListViewWrapper(self.ListViewList[number])
                a.get_item(0).select()
                SendKeys(self.ListViewList[number],string_or_int)
        else:
            window = self.Application.getWindow()
            TheListView = eval('window.listview'+ str(number))
            TheListView.select(string_or_int)

    def GetSelection(self, number):
            try:
                print('Select')
                self.Application.Wait()
                self.ListViewList = []
                hwnd = self.Application._get_most_likely_application_window_hande_by_tags_()
                EnumChildWindowsCustom(hwnd, self.HandlerChild, None, self.Application)
                a = pywinauto.controls.common_controls.ListViewWrapper(self.ListViewList[number])
                texts = a.texts()
                texts = [x for x in texts if x]
                ListOfSelection = []
                for i in texts:
                    if "Build" not in i:
                        ListOfSelection.append(i)
                print(ListOfSelection)
                if ListOfSelection == []:
                    raise ValueError('Empty List')

                return ListOfSelection
                #SendKeys(self.ListViewList[number], string)
            except:
                print("Trying again.")
                time.sleep(10)
                print('Select')
                self.Application.Wait()
                self.ListViewList = []
                hwnd = self.Application._get_most_likely_application_window_hande_by_tags_()
                EnumChildWindowsCustom(hwnd, self.HandlerChild, None, self.Application)
                a = pywinauto.controls.common_controls.ListViewWrapper(self.ListViewList[number])
                texts = a.texts()
                texts = [x for x in texts if x]
                ListOfSelection = []
                for i in texts:
                    if "Build" not in i:
                        ListOfSelection.append(i)
                print(ListOfSelection)
                if ListOfSelection == []:
                    raise ValueError('Empty List')
                return ListOfSelection
                #SendKeys(self.ListViewList[number], string)


    def SelectByIndex(self, number, index):
        print('Select by Index')
        self.Application.Wait()
        self.ListViewList = []
        hwnd = self.Application._get_most_likely_application_window_hande_by_tags_()
        try:
            EnumChildWindowsCustom(hwnd, self.HandlerChild, None, self.Application)
        except pywintypes.error:
            string = "Failed To Find -> " + 'ListView' + " Error #23456"
            raise ValueError(string)
        try:
            sleep(.10)
            win32gui.EnumChildWindows(hwnd, self.HandlerChild, None)
        except pywintypes.error:
            string = "Failed To Find -> " + 'ListView' + " Error #23456"
            raise ValueError(string)

        try:
            a = pywinauto.controls.common_controls.ListViewWrapper(self.ListViewList[number])
            a.Select(index)
        except:
            sleep(1)
            a = pywinauto.controls.common_controls.ListViewWrapper(self.ListViewList[number])
            a
            a.Select(index)
    def GetCount(self, number):
        print('Get Count')
        self.Application.Wait()
        self.ListViewList = []
        hwnd = self.Application._get_most_likely_application_window_hande_by_tags_()
        try:
            EnumChildWindowsCustom(hwnd, self.HandlerChild, None, self.Application)
        except pywintypes.error:
            string = "Failed To Find -> " + 'ListView' + " Error #23456"
            raise ValueError(string)
        try:
            sleep(.10)
            EnumChildWindowsCustom(hwnd, self.HandlerChild, None, self.Application)
        except pywintypes.error:
            string = "Failed To Find -> " + 'ListView' + " Error #23456"
            raise ValueError(string)
        try:
            a = pywinauto.controls.common_controls.ListViewWrapper(self.ListViewList[number])
            a = a.item_count()
            print
            'Count -> ' + str(a)
            return a

        except:
            sleep(1)
            a = pywinauto.controls.common_controls.ListViewWrapper(self.ListViewList[number])
            a = a.ItemCount()
            print
            'Count -> ' + str(a)
            return a
class ListBox_Class:
    def __init__(self, ApplicationObject):
        self.ListBoxList = []
        self.Application = ApplicationObject
    def HandlerChild(self, hwnd, Extra):
        if win32gui.GetClassName(hwnd) == 'ListBox':
            if win32gui.IsWindowEnabled(hwnd):
                if win32gui.IsWindowVisible(hwnd):
                    self.ListBoxList.append(hwnd)
    def GetSelection(self, number):
        print('Get Selection')
        self.Application.Wait()
        hwnd = self.Application._get_most_likely_application_window_hande_by_tags_()
        self.ListBoxList = []
        EnumChildWindowsCustom(hwnd, self.HandlerChild, None, self.Application)
        EnumChildWindowsCustom(hwnd, self.HandlerChild, None, self.Application)
        items = getComboboxItems(self.ListBoxList[number])
        self.ListBoxList = []
        return (items)
    def Select(self, number, string_or_int):
        if isinstance(string_or_int, str):
            try:
                print('Select')
                self.Application.Wait()
                self.ListBoxList = []
                hwnd = self.Application._get_most_likely_application_window_hande_by_tags_()
                EnumChildWindowsCustom(hwnd, self.HandlerChild, None, self.Application)
                a = pywinauto.controls.win32_controls.ListBoxWrapper(self.ListBoxList[number])
                a.select(0)
                SendKeys(self.ListBoxList[number], string_or_int)
                self.ListBoxList = []
            except:
                sleep(3)
                print('Select')
                self.Application.Wait()
                self.ListBoxList = []
                hwnd = self.Application._get_most_likely_application_window_hande_by_tags_()
                EnumChildWindowsCustom(hwnd, self.HandlerChild, None, self.Application)
                a = pywinauto.controls.win32_controls.ListBoxWrapper(self.ListBoxList[number])
                a.select(0)
                SendKeys(self.ListBoxList[number], string_or_int)
                self.ListBoxList = []
        else:
            window = self.Application.getWindow()
            TheListView = eval('window.listbox' + str(number))
            TheListView.select(string_or_int)



    def GetCount(self, number):
        print('Get Count')
        self.Application.Wait()
        self.ListBoxList = []
        hwnd = self.Application._get_most_likely_application_window_hande_by_tags_()
        try:
            EnumChildWindowsCustom(hwnd, self.HandlerChild, None, self.Application)
        except pywintypes.error:
            string = "Failed To Find -> " + 'ListView' + " Error #23456"
            raise ValueError(string)
        try:
            sleep(.10)
            EnumChildWindowsCustom(hwnd, self.HandlerChild, None, self.Application)
        except pywintypes.error:
            string = "Failed To Find -> " + 'ListView' + " Error #23456"
            raise ValueError(string)
        try:
            a = pywinauto.controls.win32_controls.ListBoxWrapper(self.ListBoxList[number])
            # a = pywinauto.controls.common_controls.ListBoxWrapper(self.ListBoxList[number])
            a = a.ItemCount()
            print
            'Count -> ' + str(a)
            return a

        except:
            sleep(1)
            a = pywinauto.controls.win32_controls.ListBoxWrapper(self.ListBoxList[number])
            # a = pywinauto.controls.common_controls.ListBoxWrapper(self.ListBoxList[number])
            a = a.ItemCount()
            print
            'Count -> ' + str(a)
            return a
class PushButton_Class():
    def __init__(self,ApplicationObject):
        self.Application = ApplicationObject
    def Click(self, stringOrIndex,seconds = 5):
        def Do_Click():
            print("Click")
            self.Application.Wait()
            hwnd = self.Application._get_most_likely_application_window_hande_by_tags_()
            print(hwnd)
            w_handle = hwnd
            pwa_app = pywinauto.application.Application()
            pwa_app.connect(handle=w_handle)
            window = pwa_app.window(handle=w_handle)
            ctrl = window[stringOrIndex]
            ctrl.click()
            print('Clicked PushButton ' + str(stringOrIndex))
        for i in range(seconds):
            try:
                Do_Click()
                break
            except RuntimeError as  e:
                print(e)
                sleep(1)
                if i >= seconds:
                    raise ValueError('Cannot Click')








class Edit_Class():
    def __init__(self,ApplicationObject):
        self.EditList = []
        self.Application = ApplicationObject
    def HandlerChild(self,hwnd,Extra):
        if 'Edit' in win32gui.GetClassName(hwnd):
            #if win32gui.IsWindowVisible(hwnd):
                #if win32gui.IsWindowEnabled(hwnd):
                    self.EditList.append(hwnd)

    def SetAllText(self,text):
        try:
            print("Set All Text")
            self.Application.Wait()
            hwnd = self.Application._get_most_likely_application_window_hande_by_tags_()
            EnumChildWindowsCustom(hwnd,self.HandlerChild,None)
            for i in self.EditList:
                setEditText(i, text, append=False)
            self.EditList = []
        except:
            sleep(3)
            print("Set All Text")
            self.Application.Wait()
            hwnd = self.Application._get_most_likely_application_window_hande_by_tags_()
            EnumChildWindowsCustom(hwnd,self.HandlerChild,None)
            for i in self.EditList:
                setEditText(i, text, append=False)
            self.EditList = []


    def SetText(self,number,text):
        try:
            print("Set Text")
            self.Application.Wait()
            hwnd = self.Application._get_most_likely_application_window_hande_by_tags_()
            EnumChildWindowsCustom(hwnd,self.HandlerChild,None)
            setEditText(self.EditList[number], text, append=False)
            self.EditList = []
        except:
            sleep(3)
            print("Set Text")
            self.Application.Wait()
            hwnd = self.Application._get_most_likely_application_window_hande_by_tags_()
            EnumChildWindowsCustom(hwnd,self.HandlerChild,None)
            setEditText(self.EditList[number], text, append=False)
            self.EditList = []



    def GetText(self,number):
            print("Get Text")
            self.Application.Wait()
            hwnd = self.Application._get_most_likely_application_window_hande_by_tags_()
            EnumChildWindowsCustom(hwnd,self.HandlerChild,None)
            #<class 'pywinauto.controls.win32_controls.EditWrapper'>
            edit1 = pywinauto.controls.win32_controls.EditWrapper(self.EditList[number])
            Text = edit1.texts()
            if type(Text) == list:
                Text = Text[0]
            return Text

    def Highlight(self,number):
            print("Get Text")
            self.Application.Wait()
            hwnd = self.Application._get_most_likely_application_window_hande_by_tags_()
            EnumChildWindowsCustom(hwnd,self.HandlerChild,None)
            #<class 'pywinauto.controls.win32_controls.EditWrapper'>
            edit1 = pywinauto.controls.win32_controls.EditWrapper(self.EditList[number])
            Text = edit1.highlight()


    def GetOptions(self):
            print("Get Text")
            self.Application.Wait()
            hwnd = self.Application._get_most_likely_application_window_hande_by_tags_()
            EnumChildWindowsCustom(hwnd,self.HandlerChild,None)
            #<class 'pywinauto.controls.win32_controls.EditWrapper'>
            edit = pywinauto.controls.win32_controls.EditWrapper(self.EditList[0])
            print(dir(edit))
            return dir(edit)


class RadioButton_Class:
    def __init__(self, Application):
        self.RadioList = []
        self.Application = Application
    def HandlerChild(self, hwnd, Extra):

        if win32gui.GetClassName(hwnd) == 'RadioButton':
            if win32gui.IsWindowVisible(hwnd):
                self.RadioList.append(hwnd)


    def Click(self,text = None):
        if text != None:
            text = text.replace(' ', '')
            w_handle = self.Application._get_most_likely_application_window_hande_by_tags_()
            app = pywinauto.application.Application()
            app.connect(handle=w_handle)
            window = app.Dialog
            window.wait('ready')
            Text = 'window.' + text
            print(Text)
            button = eval(Text)
            button.click()
            #app.Kill_()




class CheckBox_Class:
    def __init__(self, Application):
        self.ComboBoxList = []
        self.Application = Application
    def HandlerChild(self, hwnd, Extra):
        if win32gui.GetClassName(hwnd) == 'CheckBox':
            if win32gui.IsWindowVisible(hwnd):
                self.ComboBoxList.append(hwnd)
    def Click(self,text = None):
        if text != None:
            text = text.replace(' ','')
            from pywinauto.application import Application
            w_handle = self.Application._get_most_likely_application_window_hande_by_tags_()
            app = pywinauto.application.Application()
            app.connect(handle=w_handle)
            window = app.Dialog
            window.wait('ready')
            Text = 'window.' + text
            print(Text)
            button = eval(Text)
            button.click()
            #app.Kill_()




class ComboBox_Class:
    def __init__(self, Application):
        self.ComboBoxList = []
        self.Application = Application
    def HandlerChild(self, hwnd, Extra):

        if win32gui.GetClassName(hwnd) == 'ComboBox':
            if win32gui.IsWindowVisible(hwnd):
                self.ComboBoxList.append(hwnd)
    def Select(self, ComboNum, StringOrIndex):
        print("Select")
        self.Application.Wait()
        hwnd = self.Application._get_most_likely_application_window_hande_by_tags_()
        self.ComboBoxList = []
        for i in range(10):
            try:
                win32gui.EnumChildWindows(hwnd, self.HandlerChild, None)
                break
            except pywintypes.error as e:
                print("Trying ComboBox again")
                sleep(1)
        if type(StringOrIndex) is int:
            indexOfItem = selectComboboxItem(self.ComboBoxList[ComboNum], StringOrIndex)
            #name = self.GetTextFromIndex(ComboNum, StringOrIndex)
        else:
            control = pywinauto.controls.win32_controls.ComboBoxWrapper(self.ComboBoxList[ComboNum])
            control.select(StringOrIndex)
        self.ComboBoxList = []
    def SelectAllWithIndex(self, text):
        print('Select All With Index')
        self.Application.Wait()
        hwnd = self.Application._get_most_likely_application_window_hande_by_tags_()
        try:
            self.ComboBoxList = []
            win32gui.EnumChildWindows(hwnd, self.HandlerChild, None)
            for i in range(1000):
                try:
                    selectComboboxItem(self.ComboBoxList[i], 1)
                except:
                    pass
        except:
            pass
    ''''
    def GetTextFromIndex(self, comboBoxIndex, indexNumberOfItem):
        Say('Getting Text From Combobox' + str(comboBoxIndex) + ' ' + str(indexNumberOfItem))
        aList = self.GetSelection(comboBoxIndex)
        self.selectedItemString = aList[int(indexNumberOfItem)]
        return self.selectedItemString
    def GetSelection(self, number):
        Say('Getting Selection From Combobox ' + str(number))

        hwnd = self.Application.GetHandle()
        self.ComboBoxList = []
        win32gui.EnumChildWindows(hwnd, self.HandlerChild, None)
        items = getComboboxItems(self.ComboBoxList[number])
        return items
    def GetAmount(self, number):

        Say('Getting Amount of Choices From Combo box ' + str(number))
        hwnd = self.Application.GetHandle()
        self.ComboBoxList = []
        win32gui.EnumChildWindows(hwnd, self.HandlerChild, None)
        items = getComboboxItems(self.ComboBoxList[number])
        return len(items)
    '''









if __name__ == "__main__":
    from elan import *
    #ElanConnectPro.PushButton.Click('Options')
    #ElanConnectPro.Edit.SetText(0,'44')
    ConfigureWiFi.CheckBox.Click('ELANSTAT881013EF')





from imagescripter.core.device import Device_Class
import pyautogui
import pywinauto
win32gui = None
import win32gui
import win32gui, win32con
import win32api
from operator import itemgetter
from PIL import ImageGrab,Image
pyautogui.FAILSAFE = False

screenshot_file = r"C:\ImageScripter_2\TEMP\PC_Screenshot.png"
import win32con
import time

class PC_Class(Device_Class):
    classtype = "PC_Class"

    def Move(self,x,y):
        hwnd = self._get_most_likely_application_window_hande_by_tags_()
        w_handle = hwnd
        pwa_app = pywinauto.application.Application()
        pwa_app.connect(handle=w_handle)
        window = pwa_app.window(handle=w_handle)
        window.move_window(x,y)
        #pwa_app.wait_cpu_usage_lower(threshold=2)
        #window.wait('ready')



    def _click_(self, x, y):
        pyautogui.click(x,y)
    def _right_click_(self, x, y):
        pyautogui.rightClick(x,y)
    def _get_image_of_screen_(self,attempts = 10):
        Pass = False
        for i in range(attempts):
            try:
                handle_or_false = self._get_most_likely_application_window_hande_by_tags_()
                if handle_or_false == False:
                    return False
                    #raise ValueError("Failed to find Window Handle")
                handle = handle_or_false
                rect = win32gui.GetWindowRect(handle)
                image = ImageGrab.grab(rect)
                image.save(screenshot_file)
                Pass = True
                return screenshot_file
            except Exception as e:
                print(e)
        if Pass == False:
            raise ValueError('Something went wrong grabbing screen')




        #'''
        #for i in range(attempts):
        #    handle_or_false = self._get_most_likely_application_window_hande_by_tags_()
        #    if handle_or_false != False:
        #        handle = handle_or_false
        #        break
        #    else:
        #        time.sleep(1)
        #if handle_or_false == False:
        #    raise ValueError("Failed to find Window Handle")

        #rect = win32gui.GetWindowRect(handle)
        #image = ImageGrab.grab(rect)
        #image.save(screenshot_file)
        #return screenshot_file


    def _get_rect_(self):
        rect = win32gui.GetWindowRect(self._get_most_likely_application_window_hande_by_tags_())
        x = rect[0]
        y = rect[1]
        w = rect[2] - x
        h = rect[3] - y
        return x, y, w, h

    def Max(self):
        hwnd = self._get_most_likely_application_window_hande_by_tags_()
        win32gui.ShowWindow(hwnd, win32con.SW_MAXIMIZE)

    def Min(self):
        hwnd = self._get_most_likely_application_window_hande_by_tags_()
        win32gui.ShowWindow(hwnd, win32con.SW_MINIMIZE)


    def _hover_(self,x,y):
        print('Hover')
        pyautogui.moveTo(x, y)


        '''
        hwnd = self._get_most_likely_application_window_hande_by_tags_()
        x, y, w, h = self._get_rect_()
        if x == 0 and y == 0 and w == 0 and h == 0:
            raise ValueError("Application was not found to be closed.")
        else:
            x = (x + w) - 30
            y = y + 10
            win32api.SetCursorPos((x, y))
            #win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, x, y, 0, 0)
            #win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, x, y, 0, 0)
        '''







    def CloseWithX(self):
        try:
            print('Closing With X')
            hwnd = self._get_most_likely_application_window_hande_by_tags_()
            x, y, w, h = self._get_rect_()
            if x == 0 and y == 0 and w == 0 and h == 0:
                raise ValueError("Application was not found to be closed.")
            else:
                x = (x + w) - 30
                y = y + 10
                win32api.SetCursorPos((x, y))
                win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, x, y, 0, 0)
                win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, x, y, 0, 0)
        except Exception as e:
                print(e)
                try:
                    self.Close()
                except Exception as e:
                    print(e)


    def Wait(self):
        print('Waiting for Application')
        try:
            #self.Focus()
            print("Wait")
            hwnd = self._get_most_likely_application_window_hande_by_tags_()
            w_handle = hwnd
            pwa_app = pywinauto.application.Application()
            pwa_app.connect(handle=w_handle)
            window = pwa_app.window(handle=w_handle)
            pwa_app.wait_cpu_usage_lower(threshold=2)
            window.wait('ready')
        except Exception as e:
            print(e)
        print('Found Application')
        #app.WindowSpecification.Wait('enabled').TypeKeys('%i')  # % - alt, ^ - ctrl
        #print("Wating for Application")
        #for i in range(100):
        #    handle_or_false = self._get_most_likely_application_window_hande_by_tags_()
        #    if handle_or_false != False:
        #        handle = handle_or_false
        #        break
        #    else:
        #        time.sleep(1)
    def _get_most_likely_application_window_hande_by_tags_(self):
        FinishedMatchListTup = []
        MatchTupalList = []
        #print(self._self_tags_)
        def enumHandler(hwnd, lParam):
            if any(word in win32gui.GetWindowText(hwnd) for word in self._self_tags_):
                #print(win32gui.GetWindowText(hwnd), hwnd)
                MatchTupalList.append((win32gui.GetWindowText(hwnd), hwnd))
        win32gui.EnumWindows(enumHandler, None)
        for tup in MatchTupalList:
            x = 0
            match, handle = tup
            keywords = match.split()
            for key in keywords:
                if key in self._self_tags_:
                    x += 1
            d = (str(handle), x)
            FinishedMatchListTup.append(d)
        try:
            handle, matches = max(FinishedMatchListTup, key=itemgetter(1))
            HandleList = []
            HandleList.append(int(handle))
        except ValueError as e:
            print(e)
        try:
            return HandleList[0]
        except UnboundLocalError as e:
            return False
    def Type(self,stringToType):
        print("Typing -> ",stringToType)
        pyautogui.typewrite(stringToType)
        print("Typed -> ", stringToType)
    def Press(self,stringToType):
        print("Pressing -> ", stringToType)
        pyautogui.press(stringToType)
        print("Pressed -> ", stringToType)
    def Close(self):
        print("Closing")
        w_handle = self._get_most_likely_application_window_hande_by_tags_()
        win32gui.PostMessage(w_handle, win32con.WM_CLOSE, 0, 0)
    def Focus(self):
        print("Focusing")
        hwnd = self._get_most_likely_application_window_hande_by_tags_()
        w_handle = hwnd
        pwa_app = pywinauto.application.Application()
        pwa_app.connect(handle=w_handle)
        window = pwa_app.window(handle=w_handle)
        window.set_focus()


        ###########
        #print("Focusing")
        #pwa_app = pywinauto.application.Application()
        #w_handle = self._get_most_likely_application_window_hande_by_tags_()
        #window = pwa_app.window_(handle=w_handle)
        #window.SetFocus()



if __name__ == "__main__":
    Tags = ['ELAN','Viewer:']
    Interface = PC_Class(list_of_tags = Tags)
    Handle = Interface._get_most_likely_application_window_hande_by_tags_()
    actual_img_path = Interface._get_image_of_screen_()
    target_img_path = r"C:\ImageScripter_2\TEMP\PC_Pics\1.PNG"
    SmallButtonX, SmallButtonY = Interface._get_location_of_image_in_image(target_img_path, actual_img_path)
    SmallWith,SmallHeight = Interface._get_an_image_Width_and_height_(target_img_path)
    rect = win32gui.GetWindowRect(Handle)
    LargeAppX = rect[0]
    LargeAppY = rect[1]
    x = LargeAppX + SmallButtonX + SmallWith / 2
    y = LargeAppY + SmallButtonY + SmallHeight / 2
    Interface._click_(x, y)

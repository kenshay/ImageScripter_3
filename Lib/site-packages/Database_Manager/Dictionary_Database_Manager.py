import os
import json
import traceback
import statistics
import time
import pickle
from paths import Controler_Build_Location,exclude_directories_from_missing_scripts,All_Scripts_Folder_Location,isTesting,Dictionary_Database_Folder,Active_Build_without_EXE,Videos_For_Database_Location
from datetime import datetime
from datetime import timedelta
import re


def natural_keys(text):
    return [atoi(c) for c in re.split('(\d+)', text)]
def atoi(text):
    return int(text) if text.isdigit() else text

class Dictionary_Database_Manager_Class():
    def __init__(self, database_location):
            self.database_location_file = database_location
            self.database_folder_location = os.path.dirname(self.database_location_file)
            self.database_name = os.path.basename(self.database_location_file)
            self.database_name_without_db = self.database_name.strip('.json')
            self.Update_Caches()
            if os.path.isfile(self.database_location_file) == False:
                self.Create_New_Database()
            else:
                pass

    def get_latest_build(self):
        print('Getting latest build')
        if isTesting == False:
            Active_Build = os.listdir(Controler_Build_Location)[0]
        else:
            Active_Build = '8_4_96_0.EXE'
        Active_Build_without_EXE = Active_Build.split('.')[0]
        return Active_Build_without_EXE


    def Update_Caches(self):
        self.Cached_List_Of_Databases = self.get_list_of_databases()
        self.Cached_List_Of_Entries = []
        for List in self.Cached_List_Of_Databases:
            for entry in List:
                self.Cached_List_Of_Entries.append(entry)
        self.Cached_List_Of_Stations = self.get_all_station_names()

    def get_list_of_databases(self):
        os.chdir(Dictionary_Database_Folder)
        List_of_databases = os.listdir()
        aList = []
        Active_Build_without_EXE = self.get_latest_build()
        for database_file_name in List_of_databases:
            if Active_Build_without_EXE in database_file_name:
                print('Grabbing Data ',database_file_name)
                # database_file_name = r"\\172.16.43.21\nas\Reports\Dictionary_Databases\FrankPC_Station__8_4_81_170.json"
                # with open(database_file_name) as f:
                #    aList.append(json.load(f))
                with open(database_file_name, 'rb') as f:
                    # data = pickle.load(f)
                    # print(data)
                    aList.append(pickle.load(f))
                time.sleep(1)
            else:
                print('Not Grabbing Data ',database_file_name)
        return aList


    def get_all_station_names(self):
        List_of_stations = []
        for entry in self.Cached_List_Of_Entries:
                station_name = entry['station_name']
                station_name = station_name.split(':')[1]
                if station_name not in List_of_stations:
                    List_of_stations.append(station_name)
        return List_of_stations

    def get_all_scripts_from_station(self,station):
        List_of_scripts = []
        for entry in self.Cached_List_Of_Entries:
                station_name = entry['station_name']
                station_name = station_name.split(':')[1]
                if station_name == station:
                    script_name = entry['script_name']
                    script_name = script_name.split(':')[1]
                    if script_name not in List_of_scripts:
                        List_of_scripts.append(script_name)
        List_of_scripts.sort(key=natural_keys)
        List_of_scripts = [ele for ele in reversed(List_of_scripts)]
        return List_of_scripts






    def get_scripts_passes_and_fails_ordered_list(self,station,script):
        Pass_Fail_List = []

        for entry in self.Cached_List_Of_Entries:
                #print(entry)
                station_name = entry['station_name']
                station_name = station_name.split(':')[1]
                if station_name == station:
                    #print(station_name, ' Is ',station)
                    script_name = entry['script_name']
                    script_name = script_name.split(':')[1]
                    if script_name == script:
                        Pass = entry['pass']
                        Pass = Pass.split(':')[1]
                        if Pass == 'True':
                            Pass_Fail_List.append("p")
                        if Pass == 'False':
                            Pass_Fail_List.append("f")
                        else:
                            print(Pass)
        return Pass_Fail_List

    def get_pass_script_duration(self,station,script):
        for entry in self.Cached_List_Of_Entries:
                #print(entry['script_start_time'])
                #print(entry['date'])
                #print(entry)
                station_name = entry['station_name']
                station_name = station_name.split(':')[1]
                if station_name == station:
                    #print(station_name, ' Is ',station)
                    script_name = entry['script_name']
                    script_name = script_name.split(':')[1]




                    if script_name == script:
                        Pass = entry['pass']
                        Pass = Pass.split(':')[1]
                        if Pass == 'True':

                            script_duration = entry['script_duration']



                            script_duration = script_duration.split(':')
                            script_duration = script_duration[1]
                            script_duration = int(float(script_duration))
                            script_duration = script_duration / 60
                            script_duration = round(script_duration,2)
                            # print(script_duration)
                            return float(script_duration)
        return 0



    def get_all_fail_videos(self):
        List_Of_Fail_Videos = []


        for entry in self.Cached_List_Of_Entries:
            if entry['fail_video'] != 'fail_video:None':
                old_path = entry['fail_video'].split(':')[1]
                File_Name = os.path.basename(old_path)
                Videos_For_Database_Location
                New_Path = Videos_For_Database_Location + '\\' + File_Name
                List_Of_Fail_Videos.append(New_Path)
        return List_Of_Fail_Videos



    def get_total_scripts_passes_and_fails(self,station,script):
        Pass_Int = 0
        Fail_Int = 0

        for entry in self.Cached_List_Of_Entries:
                station_name = entry['station_name']
                station_name = station_name.split(':')[1]
                if station_name == station:
                    #print(station_name, ' Is ',station)
                    script_name = entry['script_name']
                    script_name = script_name.split(':')[1]
                    if script_name == script:
                        Pass = entry['pass']
                        Pass = Pass.split(':')[1]
                        if Pass == 'True':
                            Pass_Int += 1
                        else:
                            Fail_Int += 1

        return Pass_Int,Fail_Int



    def get_order_of_happened_scripts_passes_and_fails(self,station,script):
        List = []

        for entry in self.Cached_List_Of_Entries:
                station_name = entry['station_name']
                station_name = station_name.split(':')[1]
                if station_name == station:
                    #print(station_name, ' Is ',station)
                    script_name = entry['script_name']
                    script_name = script_name.split(':')[1]
                    if script_name == script:
                        List.append(entry)
        return List














    def get_entry_by_pass_video(self,pass_video_name):


        Match = False


        if pass_video_name.endswith('.mp4'):
            pass_video_name = pass_video_name.replace('.mp4','.avi')
        for entry in self.Cached_List_Of_Entries:
                #print(entry)
                if entry['pass'] == 'pass:True':
                    pass_video = entry['pass_video']
                    if pass_video_name in pass_video:
                        Match = True
                        return entry
        if Match == False:
            if isTesting != True:
                raise ValueError('Did not find any pass matches')
            else:
                print('Did not find any pass matches')
                return {'index_time': 1589816265.0072517, 'script_start_time': 'script_start_time:11:35:59', 'date': 'date:5/18/2020', 'script_end_time': 'script_end_time:11:37:44', 'script_name': 'this is fake', 'pass': 'pass:True', 'fail': 'fail:False', 'skip': 'skip:N/A', 'script_duration': 'script_duration:105.0', 'controller_name': 'controller_name:SC100 F8-57-2E-04-70-DB', 'station_name': 'station_name:Smoke_Station', 'controller_build': 'controller_build:8.4.96.0', 'target_img': 'target_img:None', 'templet_img': 'templet_img:None', 'error_id': 'error_id:None', 'fail_video': 'fail_video:None', 'pass_video': 'pass_video:\\\\172.16.43.21\\nas\\Reports\\Videos\\Smoke_Station__11a_Delete_Static_Door_Station_And_Com__8.4.96.0__Pass__x.avi', 'client': 'client:Default', 'index_time_string': 'index_time_string:1589816265.0072517', 'memory_used_start': 'memory_used_start:64.0318', 'memory_used_end': 'memory_used_end:64.243', 'data': 'data:', 'error': 'error:None', 'steps': "this is fake"}





    def get_list_of_all_availble_scripts(self):
        All_Script_Folder_Path = All_Scripts_Folder_Location
        list_of_scripts = []
        extensions = ('.py')  # extinctions want to search

        for dname, dirs, files in os.walk(All_Script_Folder_Path):  # this loop though directies recursively
            dirs[:] = [d for d in dirs if d not in exclude_directories_from_missing_scripts]  # exclude directory if in exclude list
            for fname in files:
                if (fname.lower().endswith(extensions)):  # check for extension
                    fpath = os.path.join(dname, fname)  # this generate full directory path for file
                    fpath = os.path.basename(fpath)
                    dirname = dname.split('Scripts\\')[1]
                    list_of_scripts.append('[' + dirname + '] ' + fpath)

        return list_of_scripts




    def get_missing_scripts_from_current_build(self):
        print('Get missing scripts')
        List_of_Missing_Scripts = []
        List_of_Ignored_Scripts = []



        List_Of_All_Available_Scripts = self.get_list_of_all_availble_scripts()
        List_of_entries = self.get_entries(back = ['script_name','station_name'])
        List_of_entry_names = []
        for ent in List_of_entries:
            name = ent['script_name'].split(':')[1].strip('.py')
            List_of_entry_names.append(name)



        for available_script in List_Of_All_Available_Scripts:
            avail_script_name = available_script.split('] ')[1].strip('.py')
            #print(avail_script_name)
            if avail_script_name in List_of_entry_names:
                pass
            else:

                #print(text)
                if 'IGNORE' in available_script:
                    #text = 'Ignored --> ' + available_script
                    text = available_script
                    List_of_Ignored_Scripts.append(text)
                else:
                    #text = 'Missing From Graph --> ' + available_script
                    text = available_script
                    List_of_Missing_Scripts.append(text)

        All = []
        #All.append('MISSING')
        for i in List_of_Missing_Scripts:
            All.append(i)
        #All.append('IGNORED')
        for i in List_of_Ignored_Scripts:
            All.append(i)
        print('Get missing scripts finished')
        return All














    def get_entry_by_fail_video(self,fail_video_name):
        Match = False


        if fail_video_name.endswith('.mp4'):
            fail_video_name = fail_video_name.replace('.mp4','.avi')
        for entry in self.Cached_List_Of_Entries:
                #print(entry)
                if entry['fail'] == 'fail:True':
                    fail_video = entry['fail_video']
                    if fail_video.endswith(fail_video_name):
                        Match = True
                        return entry

        if isTesting:
            fake = {'index_time': 1585265897.1850169, 'script_start_time': 'script_start_time:19:37:33', 'date': 'date:3/26/2020',
             'script_end_time': 'script_end_time:19:38:12', 'script_name': 'script_name:0_Detect_Controller_Crashes',
             'pass': 'pass:False', 'fail': 'fail:True', 'skip': 'skip:N/A', 'script_duration': 'script_duration:39.0',
             'controller_name': 'controller_name:frank2', 'station_name': 'station_name:FrankPC_Station',
             'controller_build': 'controller_build:8.4.88.1',
             'target_img': 'target_img:This is for Testing or something went wrong',
             'templet_img': 'templet_img:This is for Testing or something went wrong',
             'error_id': 'error_id:This is for Testing or something went wrong',
             'fail_video': 'fail_video:\\\\172.16.43.21\\nas\\Reports\\Videos\\FrankPC_Station__0_Detect_Controller_Crashes__8.4.88.1__Fail__347052103262020193445658x.avi',
             'pass_video': 'pass_video:None', 'client': 'client:Default',
             'index_time_string': 'index_time_string:1585265897.1850169', 'memory_used_start': 'memory_used_start:67.3372',
             'memory_used_end': 'memory_used_end:67.1962', 'data': 'data:',
             'error': 'error:This is for Testing or something went wrong',
             'steps': 'steps:from paths import *\nfrom imagescripter import *\nfrom elan.ssh_manager import SSH_Manager_Class\nfrom imagescripter.core.variable_file_getter import Variable_File_Getter\nif Controller_Type != \'SC100\':\n\traise ValueError(\'You need to program this to work with a non SC100 controller\')\n#####################################################################################\nIP = Variable_File_Getter.getVariableFromFile(\'Controller_IP\')\nPort = int(Elan_Controller_Port)\nUser = Elan_Controller_User_Name\nPassword = Elan_Controller_Password\nSSH_Manager = SSH_Manager_Class(ipaddress=IP, port=Port, username=User, password=Password)\nList  = SSH_Manager.get_list_folder_contents(\'../ELAN/LOG/\')\nGroup_Of_Messages = \'\'\nfor the_file in List:\n\tif \'system_log\' in the_file:\n\t\tFAIL = True\n\t\tpath = \'/ELAN/LOG/\' + the_file\n\t\tDate_Modified = \'ERROR\'\n\t\tfor i in range(10):\n\t\t\ttry:\n\t\t\t\tprint(i)\n\t\t\t\tDate_Modified = SSH_Manager.get_file_modified_info(path)\n\t\t\t\tbreak\n\t\t\texcept Exception as e:\n\t\t\t\tprint(e)\n\t\t\t\tSleep(3)\t\n\t\tcontents = SSH_Manager.get_file_contents(path)\n\t\tmessage = \'\'\n\t\tmessage += \'####################\' + "THE FILE NAME = " + the_file + \'########################\\n\'\n\t\t#message += "THE FILE NAME = " + the_file + \'\\n\'\n\t\tmessage += "DATE MODIFIED = " + Date_Modified + \'\\n\'\n\t\tmessage += "CONTENTS: " + \'\\n\'\n\t\tmessage += \'------------------------------\' + \'\\n\'\n\t\tmessage += contents + \'\\n\'\n\t\tmessage += \'------------------------------\' + \'\\n\'\n\t\tmessage += \'##############################################################\' + \'\\n\'\n\t\tGroup_Of_Messages += message + \'\\n\\n\\n\\n\' + \'=========================================================================\\n\'\n\t\tprint(message)\n\t\tprint(\'Remving -> \',path)\n\t\tfor i in range(5):\n\t\t\ttry:\n\t\t\t\tprint(i)\n\t\t\t\tSSH_Manager.remove_file(path)\n\t\t\t\tbreak\n\t\t\texcept Exception as e:\n\t\t\t\tprint(e)\n\t\tDisplay_Text(message)\n\telse:\n\t\tprint(\'No Errors Detected\')\nif Group_Of_Messages != \'\':\n\traise ValueError(Group_Of_Messages)\nelse:\n\tDisplay_Text(\'No Errors Detected\')'}
            return fake
        else:
            if Match == False:
                raise ValueError('Did not find a match wit the fail video name -> ' + fail_video_name)


    def get_entries(self,*args,back = []):
        aList = self.Cached_List_Of_Databases
        filters = args
        self.Filtered_List_Of_Entries = []
        for database_list in aList:
            for entry_dict in database_list:
                if filters != ():
                    if all(val in entry_dict.values() for val in filters):
                        if back != []:
                            entry_dict = {k: entry_dict[k] for k in back}
                        self.Filtered_List_Of_Entries.append(entry_dict)
                else:
                    if back != []:
                        entry_dict = {k: entry_dict[k] for k in back}
                    self.Filtered_List_Of_Entries.append(entry_dict)
        return self.Filtered_List_Of_Entries




        #for database_list in aList:
        #    for entry_dict in database_list:
        #        #######
        #        #if self.script_name:
        #        #    if entry_dict['script_name'] == self.script_name:
        #        ###########



        #print(type(kwargs))
        #    print(next((item for item in aList if item[key] == value), None))






        #aList = self.get_list_of_databases()
        #for database_list in aList:
        #    for entry_dict in database_list:

        #for key, value in kwargs.items():
        #    print("%s == %s" % (key, value))

        '''
        aList = self.get_list_of_databases()
        self.List_Of_Entries = []
        for database_list in aList:
            for entry_dict in database_list:
                print(entry_dict)
                self.List_Of_Entries.append(entry_dict)
        return self.List_Of_Entries
        '''



    def get_average_duration(self,script_name):
        #print(script_name)
        if script_name.endswith('.py'):
            script_name = script_name.strip('.py')
        aList = self.Cached_List_Of_Databases
        self.List_Of_Durations = []

        for database_list in aList:
            for entry_dict in database_list:
                #print(entry_dict)
                if entry_dict['script_name'] == script_name:
                    if entry_dict['pass'] == 'True':
                        start = entry_dict['script_end_time']
                        end = entry_dict['script_start_time']
                        FMT = '%H:%M:%S'
                        tdelta = datetime.strptime(start, FMT) - datetime.strptime(end, FMT)
                        tdelta.total_seconds()
                        #print(type(tdelta))
                        #for i in dir(tdelta):
                        #    print(i)
                        self.List_Of_Durations.append(tdelta.total_seconds())
        if self.List_Of_Durations != []:
            return statistics.mean(self.List_Of_Durations)
        else:
            return 0
        #average = timedelta(seconds=sum(map(lambda f: int(f[0]) * 3600 + int(f[1]) * 60 + int(f[2]), map(lambda f: f.split(':'),self.List_Of_Durations))) / len(self.List_Of_Durations)))
        #print(average)









    def enter_results_into_database(self,Info_Dict):
        if os.path.isfile(self.database_location_file) == False:
            self.Create_New_Database()


        self.Info_Dictionary = Info_Dict

        with open(self.database_location_file, 'rb') as json_file:
            Lista = pickle.load(json_file)
            Lista.append(self.Info_Dictionary)

        with open(self.database_location_file, 'wb') as json_file:
            pickle.dump(Lista, json_file)

        print('Entered Results Into Database -> ', self.database_location_file)


    def Create_New_Database(self):
        for i in range(100):
            try:
                print("Creating New Database -> ",self.database_location_file)
                lastcmd = os.getcwd()
                Folder = self.database_folder_location
                print(Folder)
                try:
                    os.chdir(Folder)
                except FileNotFoundError:
                    os.mkdir(Folder)
                    os.chdir(Folder)
                Lista = []
                #with open(self.database_location_file, 'w') as outfile:
                #    json.dump(Lista, outfile)
                with open(self.database_location_file, 'wb') as outfile:
                    pickle.dump(Lista, outfile)


                os.chdir(lastcmd)
                break
            except Exception as e:
                print(e)
                traceback.print_exc()
                time.sleep(1)


if __name__ == "__main__":
    from paths import Dictionary_Database_Location
    #database_location = Variable_File_Getter.getVariableFromFile('Database_Location')
    Dictionary_Database_Manager = Dictionary_Database_Manager_Class(Dictionary_Database_Location)
    #mean = Dictionary_Database_Manager.get_average_duration('8_PCthermostatprograms')
    #List = Dictionary_Database_Manager.get_entries('pass:True',back=['script_duration'])
    #List = Dictionary_Database_Manager.get_entries('pass:False')
    #List = Dictionary_Database_Manager.get_all_station_names()
    #List = Dictionary_Database_Manager.get_all_scripts_from_station('Smoke_Station')
    #List = Dictionary_Database_Manager.get_pass_script_duration('Smoke_Station','3c_Discovery_Add_Static_Door_Station_With_Com_Already_Added')
    #List = Dictionary_Database_Manager.get_pass_script_duration('Smoke_Station','3c_Discovery_Add_Static_Door_Station_With_Com_Already_Added')
    #List = Dictionary_Database_Manager.get_entry_by_fail_video('FrankPC_Station__0_Detect_Controller_Crashes__8.4.88.1__Fail__347052103262020193445658x.avi')
    #MP4_Video = "FrankPC_Station__5_ITP8_fusion_lms__8.4.96.0__Fail__34938178574082359x.mp4"
   # Video = 'Smoke_Station__11a_Delete_Static_Door_Station_And_Com__8.4.96.0__Pass__x.avi'

    #entry = Dictionary_Database_Manager.get_entry_by_pass_video(Video)
    missing = Dictionary_Database_Manager.get_missing_scripts_from_current_build()
    for i in missing:
        print(i)

    #Sandbox_location = r'C:\Eluminate\System\Data\Upload_Sandbox'
    #Last_Dir = os.getcwd()
    #os.chdir(Sandbox_location)
    #List_Of_Old_Files = os.listdir(Sandbox_location)
    #for old_file in List_Of_Old_Files:
    #    if os.path.exists(old_file):
    #        os.remove(old_file)
    #for Key in entry:
    #   Key_with_Txt_End = Key + '.txt'
    #   with open(Key_with_Txt_End,'w+') as f:
    #       key_value = str(entry[Key])
    #       if ':' in key_value:
    #           key_value = key_value.split(':')[1]
    #       f.write(key_value)


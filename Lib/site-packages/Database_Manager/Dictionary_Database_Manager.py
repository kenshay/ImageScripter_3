import os
import json
import traceback
import statistics
import time
import pickle
from paths import Controler_Build_Location,exclude_directories_from_missing_scripts,All_Scripts_Folder_Location,isTesting,Dictionary_Database_Folder,Active_Build_without_EXE,Videos_For_Database_Location
from datetime import datetime
from datetime import timedelta
import re

################DELETE ME ##########
#Dictionary_Database_Folder = r"C:\Users\ken.shay\Desktop\Dictionary_Databases"
#Controler_Build_Location = r"C:\Users\ken.shay\Desktop\Elan_Builds"
################################






def natural_keys(text):
    return [atoi(c) for c in re.split('(\d+)', text)]
def atoi(text):
    return int(text) if text.isdigit() else text

class Dictionary_Database_Manager_Class():
    def __init__(self, database_location,BUILD_VAR = 'default'):
            self.BUILD_VAR = BUILD_VAR
            self.database_location_file = database_location
            self.database_folder_location = os.path.dirname(self.database_location_file)
            self.database_name = os.path.basename(self.database_location_file)
            self.database_name_without_db = self.database_name.strip('.json')
            self.Update_Caches()
            if os.path.isfile(self.database_location_file) == False:
                self.Create_New_Database()
            else:
                pass


    def get_latest_build(self):
        print('Getting latest build')
        if isTesting == False:
            Active_Build = os.listdir(Controler_Build_Location)[0]
        else:
            Active_Build = '8_4_96_0.EXE'
        Active_Build_without_EXE = Active_Build.split('.')[0]
        return Active_Build_without_EXE


    def Update_Caches(self):
        self.Cached_List_Of_Databases = self.get_list_of_databases()
        self.Cached_List_Of_Entries = []
        for List in self.Cached_List_Of_Databases:
            for entry in List:
                self.Cached_List_Of_Entries.append(entry)
        self.Cached_List_Of_Stations = self.get_all_station_names()
        print('Finished Cache')






    def get_last_Amount_of_builds(self,Branch = None,AMOUNT = 3):
        import ipaddress
        os.chdir(Dictionary_Database_Folder)
        List_of_databases = os.listdir()
        List_Of_Builds = []
        for database_file_name in List_of_databases:
            if database_file_name.endswith('.json'):
                    LIST = database_file_name.split('__')
                    Station_Name = LIST[0]
                    Build = LIST[1]
                    Build = Build.replace('.json','')
                    Build = Build.replace('_','.')
                    if Branch != None:
                        if Build.startswith(Branch):
                            List_Of_Builds.append(Build)
                    else:
                        List_Of_Builds.append(Build)
        #List_Of_Builds = list(set(sorted(List_Of_Builds,reverse=True,key=natural_keys)))#[0:5]
        List_Of_Builds = list(set(List_Of_Builds))#[0:5]
        #print(List_Of_Builds)
        List_Of_Builds = sorted(List_Of_Builds, key = ipaddress.IPv4Address,reverse=True)[0:AMOUNT]
        
        print(List_Of_Builds)
        return List_Of_Builds

    def get_all_builds(self):
        import ipaddress
        os.chdir(Dictionary_Database_Folder)
        List_of_databases = os.listdir()
        List_Of_Builds = []
        for database_file_name in List_of_databases:
            if database_file_name.endswith('.json'):
                LIST = database_file_name.split('__')
                Station_Name = LIST[0]
                Build = LIST[1]
                Build = Build.replace('.json', '')
                Build = Build.replace('_', '.')
                # Dict = {'Station_Name': Station_Name, 'Build': Build}
                List_Of_Builds.append(Build)
        # List_Of_Builds = list(set(sorted(List_Of_Builds,reverse=True,key=natural_keys)))#[0:5]
        List_Of_Builds = list(set(List_Of_Builds))  # [0:5]
        # print(List_Of_Builds)
        List_Of_Builds = sorted(List_Of_Builds, key=ipaddress.IPv4Address, reverse=True)

        print(List_Of_Builds)
        return List_Of_Builds







    def get_list_of_databases(self):
        os.chdir(Dictionary_Database_Folder)
        List_of_databases = os.listdir()
        aList = []

        #print('Build_Var = ',self.BUILD_VAR)
        #print(self.get_latest_build())

        if self.BUILD_VAR == 'default':
            print('Build_Var = DEFAULT')
            Active_Build_without_EXE = self.get_latest_build()
        else:
            print('Build_Var = ',self.BUILD_VAR)
            Active_Build_without_EXE = self.BUILD_VAR
        for database_file_name in List_of_databases:
            if Active_Build_without_EXE in database_file_name:
                print('Grabbing Data ',database_file_name)
                # database_file_name = r"\\172.16.43.21\nas\Reports\Dictionary_Databases\FrankPC_Station__8_4_81_170.json"
                # with open(database_file_name) as f:
                #    aList.append(json.load(f))
                with open(database_file_name, 'rb') as f:
                    # data = pickle.load(f)
                    # print(data)
                    aList.append(pickle.load(f))
                time.sleep(1)
            else:
                print('Not Grabbing Data ',database_file_name)
        print('done')
        return aList


    def get_all_station_names(self):
        List_of_stations = []
        for entry in self.Cached_List_Of_Entries:
                station_name = entry['station_name']
                station_name = station_name.split(':')[1]
                if station_name not in List_of_stations:
                    List_of_stations.append(station_name)

        List_of_stations = set(List_of_stations)
        List_of_stations = list(List_of_stations)
        return List_of_stations

    def get_all_scripts_from_station(self,station):
        List_of_scripts = []
        for entry in self.Cached_List_Of_Entries:
                station_name = entry['station_name']
                station_name = station_name.split(':')[1]
                if station_name == station:
                    script_name = entry['script_name']
                    script_name = script_name.split(':')[1]
                    if script_name not in List_of_scripts:
                        List_of_scripts.append(script_name)
        List_of_scripts.sort(key=natural_keys)
        List_of_scripts = [ele for ele in reversed(List_of_scripts)]
        return List_of_scripts


    def get_all_scripts_from_station_by_folder(self,station):
        List_of_scripts = []
        for entry in self.Cached_List_Of_Entries:
                station_name = entry['station_name']
                station_name = station_name.split(':')[1]
                if station_name == station:
                    script_name = entry['script_name']
                    script_name = script_name.split(':')[1]
                    script_name_real = '|||' + script_name
                    ##########################Name Filter################################
                    if 'XX' not in script_name:
                        nameList = script_name.split(',')
                        print(nameList)
                        script_name = "{}/{}/{}/{}/{}".format(nameList[3], nameList[4], nameList[5], nameList[7], nameList[1]).replace(' ', ' ')
                        script_name = script_name.replace('N-A', '-')
                        script_name = script_name.replace('/0', '/^0^')
                        #print(script_name)
                    ########################################################




                    #script_name = re.sub(r'^.*?,', '', script_name)
                    if script_name not in List_of_scripts:
                        List_of_scripts.append(script_name+script_name_real)
        List_of_scripts.sort(key=natural_keys)
        SetofScripts = set(List_of_scripts)
        List_of_scripts = list(SetofScripts)
        List_of_scripts.sort(key=natural_keys)
        List_of_scripts = [ele for ele in reversed(List_of_scripts)]


        return List_of_scripts



    def get_scripts_passes_and_fails_ordered_list(self,station,script):
        Pass_Fail_List = []

        for entry in self.Cached_List_Of_Entries:
                #print(entry)
                station_name = entry['station_name']
                station_name = station_name.split(':')[1]
                if station_name == station:
                    #print(station_name, ' Is ',station)
                    script_name = entry['script_name']
                    script_name = script_name.split(':')[1]
                    if script_name == script:
                        Pass = entry['pass']
                        Pass = Pass.split(':')[1]
                        if Pass == 'True':
                            Pass_Fail_List.append("p")
                        if Pass == 'False':
                            Pass_Fail_List.append("f")
                        else:
                            print(Pass)
        return Pass_Fail_List

    def get_pass_script_duration(self,station,script):
        for entry in self.Cached_List_Of_Entries:
                #print(entry['script_start_time'])
                #print(entry['date'])
                #print(entry)
                station_name = entry['station_name']
                station_name = station_name.split(':')[1]
                if station_name == station:
                    #print(station_name, ' Is ',station)
                    script_name = entry['script_name']
                    script_name = script_name.split(':')[1]




                    if script_name == script:
                        Pass = entry['pass']
                        Pass = Pass.split(':')[1]
                        if Pass == 'True':

                            script_duration = entry['script_duration']



                            script_duration = script_duration.split(':')
                            script_duration = script_duration[1]
                            script_duration = int(float(script_duration))
                            script_duration = script_duration / 60
                            script_duration = round(script_duration,2)
                            # print(script_duration)
                            return float(script_duration)
        return 0



    def get_all_fail_videos(self):
        List_Of_Fail_Videos = []


        for entry in self.Cached_List_Of_Entries:
            if entry['fail_video'] != 'fail_video:None':
                old_path = entry['fail_video'].split(':')[1]
                File_Name = os.path.basename(old_path)
                Videos_For_Database_Location
                New_Path = Videos_For_Database_Location + '\\' + File_Name
                List_Of_Fail_Videos.append(New_Path)
        return List_Of_Fail_Videos



    def get_total_scripts_passes_and_fails(self,station,script):
        Pass_Int = 0
        Fail_Int = 0

        for entry in self.Cached_List_Of_Entries:
                station_name = entry['station_name']
                station_name = station_name.split(':')[1]
                if station_name == station:
                    #print(station_name, ' Is ',station)
                    script_name = entry['script_name']
                    script_name = script_name.split(':')[1]
                    if script_name == script:
                        Pass = entry['pass']
                        Pass = Pass.split(':')[1]
                        if Pass == 'True':
                            Pass_Int += 1
                        else:
                            Fail_Int += 1

        return Pass_Int,Fail_Int



    def get_order_of_happened_scripts_passes_and_fails(self,station,script):
        List = []

        for entry in self.Cached_List_Of_Entries:
                station_name = entry['station_name']
                station_name = station_name.split(':')[1]
                if station_name == station:
                    #print(station_name, ' Is ',station)
                    script_name = entry['script_name']
                    script_name = script_name.split(':')[1]
                    if script_name == script:
                        List.append(entry)
        return List









    def get_list_of_logs(self):
        Log_List = []
        for i in self.Cached_List_Of_Entries:
                index_time = i['index_time']
                station_name = i['station_name']
                station_name = station_name.split(':')[1]
                script_name = i['script_name']
                script_name = script_name.split(':')[1]
                date = i['date']
                date = date.split(':')[1]
                script_start_time = i['script_start_time']
                script_start_time = script_start_time.split('script_start_time:')[1]
                script_end_time = i['script_end_time']
                script_end_time = script_end_time.split('script_end_time:')[1]
                InnerList = []
                InnerList.append(index_time)
                InnerList.append(date)
                InnerList.append(script_start_time)
                InnerList.append(script_end_time)
                InnerList.append(station_name)
                InnerList.append(script_name)
                #alog = str(index_time) + ' ' + station_name + ' ' + date + ' ' + script_name + ' ' + script_start_time + ' ' + script_end_time + ' '
                #alog = str(index_time) + ' ' + script_start_time + ' ' + script_end_time + ' ' + station_name + ' ' + date + ' ' + script_name
                Log_List.append(InnerList)
        return(reversed(sorted(Log_List)))





    def get_entry_by_pass_video(self,pass_video_name):
        Match = False
        if pass_video_name.endswith('.mp4'):
            pass_video_name = pass_video_name.replace('.mp4','.avi')
        for entry in self.Cached_List_Of_Entries:
                #print(entry)
                if entry['pass'] == 'pass:True':
                    pass_video = entry['pass_video']
                    if pass_video_name in pass_video:
                        Match = True
                        return entry
        if Match == False:
            if isTesting != True:
                raise ValueError('Did not find any pass matches')
            else:
                print('Did not find any pass matches')
                return {'index_time': 1589816265.0072517, 'script_start_time': 'script_start_time:11:35:59', 'date': 'date:5/18/2020', 'script_end_time': 'script_end_time:11:37:44', 'script_name': 'this is fake', 'pass': 'pass:True', 'fail': 'fail:False', 'skip': 'skip:N/A', 'script_duration': 'script_duration:105.0', 'controller_name': 'controller_name:SC100 F8-57-2E-04-70-DB', 'station_name': 'station_name:Smoke_Station', 'controller_build': 'controller_build:8.4.96.0', 'target_img': 'target_img:None', 'templet_img': 'templet_img:None', 'error_id': 'error_id:None', 'fail_video': 'fail_video:None', 'pass_video': 'pass_video:\\\\172.16.43.21\\nas\\Reports\\Videos\\Smoke_Station__11a_Delete_Static_Door_Station_And_Com__8.4.96.0__Pass__x.avi', 'client': 'client:Default', 'index_time_string': 'index_time_string:1589816265.0072517', 'memory_used_start': 'memory_used_start:64.0318', 'memory_used_end': 'memory_used_end:64.243', 'data': 'data:', 'error': 'error:None', 'steps': "this is fake"}





    def get_list_of_all_availble_scripts(self):
        All_Script_Folder_Path = All_Scripts_Folder_Location
        list_of_scripts = []
        extensions = ('.py')  # extinctions want to search

        for dname, dirs, files in os.walk(All_Script_Folder_Path):  # this loop though directies recursively
            dirs[:] = [d for d in dirs if d not in exclude_directories_from_missing_scripts]  # exclude directory if in exclude list
            for fname in files:
                if (fname.lower().endswith(extensions)):  # check for extension
                    fpath = os.path.join(dname, fname)  # this generate full directory path for file
                    fpath = os.path.basename(fpath)
                    dirname = dname.split('Scripts\\')[1]
                    list_of_scripts.append('[' + dirname + '] ' + fpath)

        return list_of_scripts




    def get_missing_scripts_from_current_build(self):
        print('Get missing scripts')
        List_of_Missing_Scripts = []
        List_of_Ignored_Scripts = []
        List_Of_All_Available_Scripts = self.get_list_of_all_availble_scripts()
        List_of_entries = self.get_entries(back = ['script_name','station_name'])
        List_of_entry_names = []
        for ent in List_of_entries:
            name = ent['script_name'].split(':')[1].strip('.py')
            List_of_entry_names.append(name)
        for available_script in List_Of_All_Available_Scripts:
            avail_script_name = available_script.split('] ')[1].strip('.py')
            #print(avail_script_name)
            if avail_script_name in List_of_entry_names:
                pass
            else:

                #print(text)
                if 'IGNORE' in available_script:
                    #text = 'Ignored --> ' + available_script
                    text = available_script
                    List_of_Ignored_Scripts.append(text)
                else:
                    #text = 'Missing From Graph --> ' + available_script
                    text = available_script
                    List_of_Missing_Scripts.append(text)

        All = []
        #All.append('MISSING')
        for i in List_of_Missing_Scripts:
            All.append(i)
        #All.append('IGNORED')
        for i in List_of_Ignored_Scripts:
            All.append(i)
        print('Get missing scripts finished')
        return All




    def get_missing_scripts_from_current_build_Test(self):
        print('Get missing scripts')
        List_of_Missing_Scripts = []
        List_of_Ignored_Scripts = []
        List_Of_All_Available_Scripts = self.get_list_of_all_availble_scripts()
        List_of_entries = self.get_entries(back = ['script_name','station_name'])
        #return List_of_entries

        List_of_entry_names = []
        for ent in List_of_entries:
            name = ent['script_name'].split(':')[1].strip('.py')
            List_of_entry_names.append(name)
        return  List_Of_All_Available_Scripts

        '''
        
        for available_script in List_Of_All_Available_Scripts:
            avail_script_name = available_script.split('] ')[1].strip('.py')
            #print(avail_script_name)
            if avail_script_name in List_of_entry_names:
                pass
            else:

                #print(text)
                if 'IGNORE' in available_script:
                    #text = 'Ignored --> ' + available_script
                    text = available_script
                    List_of_Ignored_Scripts.append(text)
                else:
                    #text = 'Missing From Graph --> ' + available_script
                    text = available_script
                    List_of_Missing_Scripts.append(text)

        All = []
        #All.append('MISSING')
        for i in List_of_Missing_Scripts:
            All.append(i)
        #All.append('IGNORED')
        for i in List_of_Ignored_Scripts:
            All.append(i)
        print('Get missing scripts finished')
        return All
        '''








    def get_entry_by_fail_video(self,fail_video_name):
        Match = False


        if fail_video_name.endswith('.mp4'):
            fail_video_name = fail_video_name.replace('.mp4','.avi')
        for entry in self.Cached_List_Of_Entries:
                #print(entry)
                if entry['fail'] == 'fail:True':
                    fail_video = entry['fail_video']
                    if fail_video.endswith(fail_video_name):
                        Match = True
                        return entry

        if isTesting:
            fake = {'index_time': 1585265897.1850169, 'script_start_time': 'script_start_time:19:37:33', 'date': 'date:3/26/2020',
             'script_end_time': 'script_end_time:19:38:12', 'script_name': 'script_name:0_Detect_Controller_Crashes',
             'pass': 'pass:False', 'fail': 'fail:True', 'skip': 'skip:N/A', 'script_duration': 'script_duration:39.0',
             'controller_name': 'controller_name:frank2', 'station_name': 'station_name:FrankPC_Station',
             'controller_build': 'controller_build:8.4.88.1',
             'target_img': 'target_img:This is for Testing or something went wrong',
             'templet_img': 'templet_img:This is for Testing or something went wrong',
             'error_id': 'error_id:This is for Testing or something went wrong',
             'fail_video': 'fail_video:\\\\172.16.43.21\\nas\\Reports\\Videos\\FrankPC_Station__0_Detect_Controller_Crashes__8.4.88.1__Fail__347052103262020193445658x.avi',
             'pass_video': 'pass_video:None', 'client': 'client:Default',
             'index_time_string': 'index_time_string:1585265897.1850169', 'memory_used_start': 'memory_used_start:67.3372',
             'memory_used_end': 'memory_used_end:67.1962', 'data': 'data:',
             'error': 'error:This is for Testing or something went wrong',
             'steps': 'steps:from paths import *\nfrom imagescripter import *\nfrom elan.ssh_manager import SSH_Manager_Class\nfrom imagescripter.core.variable_file_getter import Variable_File_Getter\nif Controller_Type != \'SC100\':\n\traise ValueError(\'You need to program this to work with a non SC100 controller\')\n#####################################################################################\nIP = Variable_File_Getter.getVariableFromFile(\'Controller_IP\')\nPort = int(Elan_Controller_Port)\nUser = Elan_Controller_User_Name\nPassword = Elan_Controller_Password\nSSH_Manager = SSH_Manager_Class(ipaddress=IP, port=Port, username=User, password=Password)\nList  = SSH_Manager.get_list_folder_contents(\'../ELAN/LOG/\')\nGroup_Of_Messages = \'\'\nfor the_file in List:\n\tif \'system_log\' in the_file:\n\t\tFAIL = True\n\t\tpath = \'/ELAN/LOG/\' + the_file\n\t\tDate_Modified = \'ERROR\'\n\t\tfor i in range(10):\n\t\t\ttry:\n\t\t\t\tprint(i)\n\t\t\t\tDate_Modified = SSH_Manager.get_file_modified_info(path)\n\t\t\t\tbreak\n\t\t\texcept Exception as e:\n\t\t\t\tprint(e)\n\t\t\t\tSleep(3)\t\n\t\tcontents = SSH_Manager.get_file_contents(path)\n\t\tmessage = \'\'\n\t\tmessage += \'####################\' + "THE FILE NAME = " + the_file + \'########################\\n\'\n\t\t#message += "THE FILE NAME = " + the_file + \'\\n\'\n\t\tmessage += "DATE MODIFIED = " + Date_Modified + \'\\n\'\n\t\tmessage += "CONTENTS: " + \'\\n\'\n\t\tmessage += \'------------------------------\' + \'\\n\'\n\t\tmessage += contents + \'\\n\'\n\t\tmessage += \'------------------------------\' + \'\\n\'\n\t\tmessage += \'##############################################################\' + \'\\n\'\n\t\tGroup_Of_Messages += message + \'\\n\\n\\n\\n\' + \'=========================================================================\\n\'\n\t\tprint(message)\n\t\tprint(\'Remving -> \',path)\n\t\tfor i in range(5):\n\t\t\ttry:\n\t\t\t\tprint(i)\n\t\t\t\tSSH_Manager.remove_file(path)\n\t\t\t\tbreak\n\t\t\texcept Exception as e:\n\t\t\t\tprint(e)\n\t\tDisplay_Text(message)\n\telse:\n\t\tprint(\'No Errors Detected\')\nif Group_Of_Messages != \'\':\n\traise ValueError(Group_Of_Messages)\nelse:\n\tDisplay_Text(\'No Errors Detected\')'}
            return fake
        else:
            if Match == False:
                raise ValueError('Did not find a match wit the fail video name -> ' + fail_video_name)


    def get_entries(self,*args,back = []):
        aList = self.Cached_List_Of_Databases
        filters = args
        self.Filtered_List_Of_Entries = []
        for database_list in aList:
            for entry_dict in database_list:
                if filters != ():
                    if all(val in entry_dict.values() for val in filters):
                        if back != []:
                            entry_dict = {k: entry_dict[k] for k in back}
                        self.Filtered_List_Of_Entries.append(entry_dict)
                else:
                    if back != []:
                        entry_dict = {k: entry_dict[k] for k in back}
                    self.Filtered_List_Of_Entries.append(entry_dict)
        return self.Filtered_List_Of_Entries




        #for database_list in aList:
        #    for entry_dict in database_list:
        #        #######
        #        #if self.script_name:
        #        #    if entry_dict['script_name'] == self.script_name:
        #        ###########



        #print(type(kwargs))
        #    print(next((item for item in aList if item[key] == value), None))






        #aList = self.get_list_of_databases()
        #for database_list in aList:
        #    for entry_dict in database_list:

        #for key, value in kwargs.items():
        #    print("%s == %s" % (key, value))

        '''
        aList = self.get_list_of_databases()
        self.List_Of_Entries = []
        for database_list in aList:
            for entry_dict in database_list:
                print(entry_dict)
                self.List_Of_Entries.append(entry_dict)
        return self.List_Of_Entries
        '''



    def get_average_duration(self,script_name):
        #print(script_name)
        if script_name.endswith('.py'):
            script_name = script_name.strip('.py')
        aList = self.Cached_List_Of_Databases
        self.List_Of_Durations = []

        for database_list in aList:
            for entry_dict in database_list:
                #print(entry_dict)
                if entry_dict['script_name'] == script_name:
                    if entry_dict['pass'] == 'True':
                        start = entry_dict['script_end_time']
                        end = entry_dict['script_start_time']
                        FMT = '%H:%M:%S'
                        tdelta = datetime.strptime(start, FMT) - datetime.strptime(end, FMT)
                        tdelta.total_seconds()
                        #print(type(tdelta))
                        #for i in dir(tdelta):
                        #    print(i)
                        self.List_Of_Durations.append(tdelta.total_seconds())
        if self.List_Of_Durations != []:
            return statistics.mean(self.List_Of_Durations)
        else:
            return 0
        #average = timedelta(seconds=sum(map(lambda f: int(f[0]) * 3600 + int(f[1]) * 60 + int(f[2]), map(lambda f: f.split(':'),self.List_Of_Durations))) / len(self.List_Of_Durations)))
        #print(average)









    def enter_results_into_database(self,Info_Dict):
        if os.path.isfile(self.database_location_file) == False:
            self.Create_New_Database()


        self.Info_Dictionary = Info_Dict

        with open(self.database_location_file, 'rb') as json_file:
            Lista = pickle.load(json_file)
            Lista.append(self.Info_Dictionary)

        with open(self.database_location_file, 'wb') as json_file:
            pickle.dump(Lista, json_file)

        print('Entered Results Into Database -> ', self.database_location_file)


    def Create_New_Database(self):
        for i in range(100):
            try:
                print("Creating New Database -> ",self.database_location_file)
                lastcmd = os.getcwd()
                Folder = self.database_folder_location
                #print(Folder)
                try:
                    os.chdir(Folder)
                except FileNotFoundError:
                    os.mkdir(Folder)
                    os.chdir(Folder)
                Lista = []
                #with open(self.database_location_file, 'w') as outfile:
                #    json.dump(Lista, outfile)
                with open(self.database_location_file, 'wb') as outfile:
                    pickle.dump(Lista, outfile)


                os.chdir(lastcmd)
                break
            except Exception as e:
                print(e)
                traceback.print_exc()
                time.sleep(1)


if __name__ == "__main__":
    #pass
    from paths import Dictionary_Database_Location
    Dictionary_Database_Manager = Dictionary_Database_Manager_Class(Dictionary_Database_Location,BUILD_VAR='8_5_17_0')
    #List = Dictionary_Database_Manager.get_list_of_logs()
    #for i in List:
    #    print(i)


    #List = Dictionary_Database_Manager.get_all_scripts_from_station_by_folder('Smoke_Station')
    #List = Dictionary_Database_Manager.get_all_scripts_from_station('Smoke_Station')


    #mean = Dictionary_Database_Manager.get_average_duration('8_PCthermostatprograms')
    #List = Dictionary_Database_Manager.get_entries('pass:True',back=['script_duration'])
    #List = Dictionary_Database_Manager.get_entries('pass:False')
    #List = Dictionary_Database_Manager.get_all_station_names()
    #List = Dictionary_Database_Manager.get_all_scripts_from_station('Smoke_Station')
    #List = Dictionary_Database_Manager.get_pass_script_duration('Smoke_Station','3c_Discovery_Add_Static_Door_Station_With_Com_Already_Added')
    #List = Dictionary_Database_Manager.get_pass_script_duration('Smoke_Station','3c_Discovery_Add_Static_Door_Station_With_Com_Already_Added')
    #List = Dictionary_Database_Manager.get_entry_by_fail_video('FrankPC_Station__0_Detect_Controller_Crashes__8.4.88.1__Fail__347052103262020193445658x.avi')
    #MP4_Video = "FrankPC_Station__5_ITP8_fusion_lms__8.4.96.0__Fail__34938178574082359x.mp4"
   # Video = 'Smoke_Station__11a_Delete_Static_Door_Station_And_Com__8.4.96.0__Pass__x.avi'

    #entry = Dictionary_Database_Manager.get_entry_by_pass_video(Video)
    #List = Dictionary_Database_Manager.get_missing_scripts_from_current_build_Test()
    #List = Dictionary_Database_Manager.get_list_of_all_availble_scripts()
    #for i in List:
    #    print(i)

    #Sandbox_location = r'C:\Eluminate\System\Data\Upload_Sandbox'
    #Last_Dir = os.getcwd()
    #os.chdir(Sandbox_location)
    #List_Of_Old_Files = os.listdir(Sandbox_location)
    #for old_file in List_Of_Old_Files:
    #    if os.path.exists(old_file):
    #        os.remove(old_file)
    #for Key in entry:
    #   Key_with_Txt_End = Key + '.txt'
    #   with open(Key_with_Txt_End,'w+') as f:
    #       key_value = str(entry[Key])
    #       if ':' in key_value:
    #           key_value = key_value.split(':')[1]
    #       f.write(key_value)

